<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.png">

    <title>
        
          The Verge - Ethereum&#39;s Efficient Verifiable Query Technique: Verkle Trees - AntChain Open Labs | Blogs
        
    </title>

    <link rel="canonical" href="https://antchainopenlabs.github.io/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 7.0.0-rc2"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://openlabs-intl.antdigital.com/home">AntChain Open Labs</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://antchainopenlabs.github.io/img/logo.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/tag-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Blockchain Technology" title="Blockchain Technology">Blockchain Technology</a>
                        
                    </div>
                    <h1>The Verge - Ethereum&#39;s Efficient Verifiable Query Technique: Verkle Trees</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by AntChain Open Labs on
                        2024-01-25
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/01.png" alt="image"></p>
<p>On the last day of 2023, Vitalik shared Ethereumâ€™s roadmap for 2023 on Twitter, summarizing the progress of Ethereum over the year. The roadmap section â€œThe Vergeâ€ described how Ethereumâ€™s technology could verify blockchain states more simply and efficiently. A core concept mentioned there is the Verkle Trees. So, what are Verkle Trees, why Ethereum needs it, and how do Verkle Trees solve problems? The goal of this article is to answer these questions for readers without delving too deeply into cryptography and mathematics, helping those with some understanding of Ethereum quickly grasp the concept of Verkle Trees.</p>
<h1 id="Verifiable-Query"><a href="#Verifiable-Query" class="headerlink" title="Verifiable Query"></a>Verifiable Query</h1><p>Verifiable query technology is widely researched in the field of traditional databases, primarily used to solve trust issues with external databases. In many scenarios, data owners might choose not to store data themselves but instead entrust their database needs to a third party to provide database services (such as cloud databases). However, because third parties are not always trustworthy, the credibility of the query results they return to users is difficult to guarantee. The current verifiable query solutions for traditional databases mainly fall into two categories: those based on ADS (Authenticated Data Structures) and those based on verifiable computation.</p>
<p>ADS is a verifiable query technique extensively used in traditional databases, mostly built upon structures like Merkle Trees or similar accumulative structures. With the evolution of cryptographic tools, many researchers have gradually begun to explore the use of verifiable computation techniques to address issues with untrustworthy queries. Some verifiable computation schemes based on Zero-Knowledge Proof protocols, such as SNARKs, can indirectly support verifiable queries for external databases. These schemes support a wide variety of query types and generate less verification information, but they have higher computational overheads.</p>
<p>Currently, Ethereum uses Merkle Trees to implement verifiable queries, and the Verkle Tree technology is also based on Merkle Tree technology. Therefore, letâ€™s first introduce Merkle Trees to help readers understand the role of verifiable queries using them as an example.</p>
<h1 id="Merkle-Trees"><a href="#Merkle-Trees" class="headerlink" title="Merkle Trees"></a>Merkle Trees</h1><h2 id="Definition-and-Characteristics-of-Merkle-Trees"><a href="#Definition-and-Characteristics-of-Merkle-Trees" class="headerlink" title="Definition and Characteristics of Merkle Trees"></a>Definition and Characteristics of Merkle Trees</h2><p>Merkle Trees are a tree-like structure commonly used in cryptography, suitable for solving data integrity issues. Below is a typical Merkle Tree structure: the leaf nodes represent the original data or their hash values, and each non-leaf (internal) node contains the combined hash of its child nodes.</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/02.png" alt="image"></p>
<p><strong>Merkle Trees have two important characteristics:</strong></p>
<ol>
<li>Tamper-Resistance: Merkle Trees are typically constructed using collision-resistant hash functions, making it computationally infeasible to find two different messages that produce the same hash value. From the structure of a Merkle Tree, it is apparent that any modification to transaction data within a leaf node will result in a change to the root hash of the tree.</li>
<li>Efficient Integrity Verification of Large Datasets: Verifiers only need to store the root hash of the Merkle Tree to verify the integrity of any data. This is achieved without transmitting the complete data set, but rather by using sibling nodes along the path from the leaf to the root, known as a Merkle Path. These sibling nodes can be used to reconstruct the root hash for verification purposes.</li>
</ol>
<h2 id="How-to-construct-a-Merkle-proof"><a href="#How-to-construct-a-Merkle-proof" class="headerlink" title="How to construct a Merkle proof?"></a>How to construct a Merkle proof?</h2><p>In a common verifiable query scenario, there is a prover and a verifier. The prover needs to generate a proof and send it to the verifier. Corresponding to the Ethereum network, a typical application scenario is where a light node (a client that only stores block headers) queries transaction data from a full node or an archive node (clients with all data) and obtains a Merkle proof to locally verify whether the query result is correct.</p>
<p><strong>The Merkle proof consists of the following three parts:</strong></p>
<ol>
<li>The root hash of the Merkle tree for the complete dataset.</li>
<li>The data block whose integrity needs to be proven.</li>
<li>The Merkle Path, which includes the values of all sibling nodes on the path from the leaf node to the root node.</li>
</ol>
<p>Among these, the root hash of the Merkle tree needs to be sent to the verifier in advance through a trustworthy means, and the verifier must trust this value. In Ethereum, the trustworthiness of block data is ensured by the consensus algorithm, and the root hash of the Merkle tree is contained within the block header.</p>
<p>Below is a specific example: when the prover needs to prove to the verifier that â€œ4â€ is a data block existing in the dataset, and the verifier holds the trusted root hash â€œ1d25â€ of the complete datasetâ€™s Merkle tree, then the prover only needs to provide all the data marked in blue. Assuming there are n pieces of data in the set, at most <strong>$log_2(n)$</strong> hash computations are needed to verify the correctness of any data block.</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/03.png" alt="image"></p>
<p>Ethereumâ€™s light nodes synchronize only the block headers, which contain the roots of Merkle Trees for various sets of data (state tree, transaction tree, receipt tree). When a light node queries a full node for a particular leaf nodeâ€™s data in the tree, the full node returns the original data along with the corresponding Merkle proof path. This allows the light node to trust the correctness of the query result.</p>
<h2 id="Variants-of-Merkle-Trees"><a href="#Variants-of-Merkle-Trees" class="headerlink" title="Variants of Merkle Trees"></a>Variants of Merkle Trees</h2><p>Building upon the foundation of Merkle Trees, they can be combined and modified with other data structures to achieve new characteristics based on different objectives. To cater to various verifiable query scenarios, Merkle Trees can be extended to various indexed data structures, such as Merkle-B Trees (MBT). For efficient execution of operations like insertion, deletion, and querying, the Ethereum team proposed the Merkle Patricia Tree (MPT).</p>
<h3 id="Merkle-B-Tree"><a href="#Merkle-B-Tree" class="headerlink" title="Merkle-B Tree"></a>Merkle-B Tree</h3><p>The Merkle-B Tree (MBT) is mainly used for handling verifiable range queries. Let ğ‘“ be the fan-out of the MBT (the number of child nodes for each node). Based on the B+ tree structure, each internal node of the MBT, besides storing ğ‘“ - 1 index keys and pointers to ğ‘“ child nodes, also maintains the hash values of all its child nodes in a summarized form. Below is a representation of the structure of leaf nodes and internal nodes in an MBT.</p>
<p>When it is necessary to prove that the data returned from a certain range query conforms to the specified range, the server that computes the Verification Object (VO) must first perform two top-down search operations to find the left and right boundaries. It must also return all the data within this boundary as well as the hashes of all the branches needed to construct the path to the root hash.</p>
<p>The drawback of this data structure is that the returned VO can only prove that the query results are within the requested query range, but it cannot prove that the returned results are complete.</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/04.png" alt="image"></p>
<h3 id="Merkle-Patricia-Tree"><a href="#Merkle-Patricia-Tree" class="headerlink" title="Merkle Patricia Tree"></a>Merkle Patricia Tree</h3><p>If a naive Merkle Tree is used to provide verifiable queries, the time-consuming process of regenerating the Merkle tree root after each data insertion or deletion can become significant. In addition, it necessitates the maintenance of additional data search trees for storage. The Merkle Patricia Tree (MPT) combines attributes of a Radix Tree (compact prefix tree) and a Merkle Tree, allowing it to perform insertions, deletions, and queries in O(log(N)) time. For a complete understanding of MPT, readers can refer to detailed technical articles on the subject. This article will only introduce some basic definitions and provide examples to help readers quickly understand MPT.</p>
<p>Ethereumâ€™s underlying structure employs a key-value database for storage, meaning data is stored in the form of key-value pairs. The MPT is also decomposed into key-value pairs for storage. We define the logical structure of MPT nodes as follows:</p>
<ul>
<li>index</li>
<li>path</li>
<li>data</li>
</ul>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/05.png" alt="image"></p>
<p>In the context of the Merkle Patricia Tree (MPT), the â€œindexâ€ refers to the key of a key-value pair, while the â€œpathâ€ combined with the â€œdataâ€ constitutes the value of the key-value pair. The index actually stores the hash of the Merkle tree node, and the path corresponds to the path string used in the prefix tree to find the target node. Ethereum uses hexadecimal strings as path strings, and therefore the width of the MPT is 16. The data is the target data corresponding to the path.</p>
<p>Below is an example of an MPT that has been optimized with compressed prefixes, storing the following key-value pair data:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  &#x27;cab8&#x27;<span class="punctuation">:</span> &#x27;dog&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;cabe&#x27;<span class="punctuation">:</span> &#x27;cat&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;<span class="number">39</span>&#x27;<span class="punctuation">:</span> &#x27;chicken&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;<span class="number">395</span>&#x27;<span class="punctuation">:</span> &#x27;duck&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;<span class="number">56</span>f0&#x27;<span class="punctuation">:</span> &#x27;horse&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/06.png" alt="image"></p>
<p>To find the data â€œduckâ€ using the path â€œ395,â€ you would start at the root hash and proceed through hashA, hashC, and hashD to ultimately reach the target data. Hereâ€™s a step-by-step guide:</p>
<ol>
<li><strong>Root Hash</strong>: This is the entry point of the Merkle Patricia Tree (MPT), and you would use it to find the first node.</li>
<li><strong>hashA</strong>: Based on the root hash, you would retrieve the node or content identified by hashA. Since the path is â€œ395,â€ youâ€™re looking for the part of the tree that will lead you to â€œ3â€.</li>
<li><strong>hashC</strong>: After accessing the content of hashA, you continue to follow the path. The next segment, â€œ9â€, leads you to hashC.</li>
<li><strong>hashD</strong>: Finally, continuing down the path, the last segment â€œ5â€ points you to hashD, which contains the value â€œduckâ€.</li>
</ol>
<p>At each step in the path, the MPT leverages the properties of both the Radix Tree, for finding the correct path based on the key, and the Merkle Tree, for ensuring the integrity of the data through hash links. The â€œpathsâ€ in the tree are typically represented with a hexadecimal encoding, which corresponds with the treeâ€™s branching factor of 16. Each node in the path includes enough hash pointers (to children nodes) and values to verify the integrity of the data and to navigate through the tree.</p>
<p>Please note that in a real MPT, the paths and the data would be encoded and stored in a specific format, and additional types of nodes (such as extension nodes and leaf nodes) help to optimize the structure for efficiency in different scenarios.</p>
<h1 id="Vector-Commitment"><a href="#Vector-Commitment" class="headerlink" title="Vector Commitment"></a>Vector Commitment</h1><p>Commitment[1] schemes are cryptographic primitives that ensure data privacy and integrity. They are widely used in scenarios such as zero-knowledge proofs and secure multiparty computation. A basic commitment scheme is divided into two stages: the commit phase and the reveal (or open) phase.</p>
<ol>
<li><strong>Commit Phase</strong>: In this phase, the committer uses a cryptographic algorithm to bind a message to a commitment value and sends this commitment value to the recipient. At this stage, the commitment possesses two properties: hiding and binding. Hiding ensures that the content of the committed message is unknown to everyone except the committer. Binding ensures that once a commitment has been made, it cannot be altered by anybody, including the committer.</li>
<li><strong>Reveal (Open) Phase</strong>: During this phase, the committer can prove to the recipient that the commitment value they received is a valid commitment to the original message. The commitment has the property of correctness, meaning that if both the committer and the recipient follow the protocol correctly, the recipient will be convinced that the commitment value they received during the commit phase is a valid commitment to the original message.</li>
</ol>
<p>Vector Commitment is a special type of commitment scheme proposed by Catalano et al. [2] that allows a committer to make a commitment to an ordered set of messages ğ‘š &#x3D; âŸ¨ğ‘š1 , ğ‘š2 , â€¦, ğ‘šğ‘ âŸ© and to reveal (open) at any specified position to prove that message ğ‘šğ‘– is the ith committed message. In vector commitments, binding means that no one can open the same position to reveal different messages.</p>
<p>A vector commitment scheme typically consists of the following algorithms:</p>
<ul>
<li><p>$Gen(1^Î»,q)â†’pp$ The key generation algorithm, upon input of a security parameter Î» and vector length;</p>
</li>
<li><p>$Commit(pp,<\it m_1,m_2,...,m_q\gt)â†’(C,aux)$, Commitment algorithm, upon input of public parameters and a vector composed of q messages, outputs a commitment C and auxiliary information aux;</p>
</li>
<li><p>$Open(pp,i,m_i,C,aux)â†’Ï€$, Proof generation algorithm, given public parameters pp and relevant information, generates a proof Ï€ through the commitment C and auxiliary information aux, if and only if $ğ‘š_ğ‘–$ is the ith message in the message vector;</p>
</li>
<li><p>$Verify(pp,C,i,m,Ï€)â†’{accept \ or\  reject}$, Verification algorithm, given public parameters pp, commitment C, message m, index i, and proof Ï€, outputs accept if and only if message m is the ith message in the original vector and Ï€ passes verification; otherwise, it outputs reject.</p>
</li>
</ul>
<h1 id="Verkle-Trees"><a href="#Verkle-Trees" class="headerlink" title="Verkle Trees"></a>Verkle Trees</h1><h2 id="Definition-and-Characteristics-of-Verkle-Trees"><a href="#Definition-and-Characteristics-of-Verkle-Trees" class="headerlink" title="Definition and Characteristics of Verkle Trees"></a>Definition and Characteristics of Verkle Trees</h2><p><strong>Definitionï¼šVerkle Trees</strong> &#x3D; <strong>V</strong>ector Commitments + M<strong>erkle Trees</strong>ã€‚</p>
<p><strong>Please note</strong>ï¼šVitalik Buterin, the co-founder of Ethereum, has a <a href="https://vitalik.eth.limo/general/2021/06/18/verkle.html" target="_blank" rel="noopener">blog</a> post specifically dedicated to introducing Verkle trees. This chapter adds some background and mathematical knowledge based on his blog. Some of the data and illustrations in the following text are derived from his blog.</p>
<p>Verkle Trees (VTs) are characterized by providing smaller proofs compared to Merkle Trees. For data on the scale of billions of entries, a Merkle tree might generate proofs around 1KB in size, whereas Verkle tree proofs can be less than 150 bytes. This compact proof size is advantageous for implementing â€œ<a href="https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/stateless-clients/" target="_blank" rel="noopener">stateless clients</a>â€œ.</p>
<p>The structure of a Verkle tree is somewhat similar to that of the Merkle Patricia Tree (MPT). Hereâ€™s an example of its structure. The nodes of a Verkle tree can be: (i) Empty, (ii) Leaf nodes containing a key and its corresponding value, or (iii) Internal nodes with a fixed number of child nodes. This number of children is also referred to as the â€œwidthâ€ of the tree.</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/07.png" alt="image"></p>
<p>The difference between VT (Verkle Trees) and MPT (Merkle Patricia Trees) lies primarily in how the tree width (or fan-out, which refers to the number of child nodes a node in the tree has) affects their efficiency. In the case of MPT, if the width is larger, it tends to be less efficient because a greater width means more sibling nodes, which could lead to longer update times for the MPT and larger proof sizes. Conversely, for VT, a wider tree width results in smaller proofs. The only restriction is that if the width is too high, the time it takes to generate a proof can become longer.</p>
<p>In Ethereumâ€™s <a href="https://notes.ethereum.org/@vbuterin/verkle_tree_eip" target="_blank" rel="noopener">design proposals</a> for VTs, a width of 256 is suggested, which is significantly larger than the current 16 for MPT. Such a large width is feasible in VTs because of the use of advanced cryptographic techniques, such as vector commitments, that enable compact proofs regardless of the treeâ€™s width. This compression technique allows Verkle Trees to scale more efficiently in terms of proof size. The subsequent text will explain the features mentioned above in more detail. </p>
<h2 id="Commitment-and-Proof-of-Verkle-Trees"><a href="#Commitment-and-Proof-of-Verkle-Trees" class="headerlink" title="Commitment and Proof of Verkle Trees"></a>Commitment and Proof of Verkle Trees</h2><p>Letâ€™s see how proofs are generated in an MPT: The proof needs to include the hash values of all the side nodes (or sister nodes) on the path from the root node to the target leaf node. Taking â€œ4ceâ€ as an example, the parts marked in red in the diagram below are the nodes that need to be included in the returned proof.</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/08.png" alt="image"></p>
<p>In Verkle trees, you do not need to provide sibling nodes; instead, you only need to provide the path along with some additional data as evidence.</p>
<p>So how to generate commitments for a VT? The hash function used for computation is not a conventional hash but uses vector commitments.</p>
<p>After replacing the hash function with a commitment generation algorithm from vector commitments, the so-called root hash is now a root commitment. If any nodeâ€™s data is tampered with, it will ultimately affect the root commitment.</p>
<p>How to generate a proof? As shown in the diagram below, you only need to provide three sub-proofs, each of which can prove that a node on the path exists at a certain position within its parent node. The wider the width, the fewer the layers, and consequently, the fewer sub-proofs are required.</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/09.png" alt="image"></p>
<p>In practical implementations, polynomial commitments are utilized (which can be implemented simply and efficiently for vector commitments), allowing for a commitment to a polynomial. The two most user-friendly polynomial commitment schemes are â€œ<a href="https://notes.ethereum.org/@vbuterin/verkle_tree_eip" target="_blank" rel="noopener">KZG commitments</a>â€œ and â€œ<a href="https://twitter.com/VitalikButerin/status/1371844878968176647" target="_blank" rel="noopener">bulletproof-style polynomial commitments</a> (the former has a commitment size of 48 bytes, while the latter is 32 bytes).</p>
<p>If you employ KZG commitments and proofs, the proof for each intermediate node is merely 96 bytes, which represents a space saving of nearly three times compared to a basic Merkle tree (assuming a width of 256).</p>
<p>The theoretical time complexity for operations on Merkle trees and Verkle trees is as follows:</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/10.png" alt="image"></p>
<p>The Verkle proof scheme introduced so far is quite basic; in fact, there are further advanced optimization strategies available.</p>
<h2 id="Optimization-Merging-the-Proofs"><a href="#Optimization-Merging-the-Proofs" class="headerlink" title="Optimization: Merging the Proofs"></a>Optimization: Merging the Proofs</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><p>Compared to generating a proof for each layer of commitments on a path, the characteristic of polynomial commitments can be utilized to achieve â€œproving the parent-child relationship between all commitments on the path with a proof of fixed size, which can include an unlimited number of elements.â€ To understand specifically how this is accomplished, it is necessary to introduce some mathematical knowledge for explanation. This article will involve some mathematical formulas but will not cover the cryptographic part of the proof in principle. For the specific method, please refer to <a href="https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html" target="_blank" rel="noopener">scheme that implements multiproofs through random evaluation</a>.</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/11.png" alt="image"></p>
<h3 id="Mathematical-derivation"><a href="#Mathematical-derivation" class="headerlink" title="Mathematical derivation"></a>Mathematical derivation</h3><p><strong>First, letâ€™s introduce some basic concepts about polynomials in mathematics: how do we perform polynomial reduction, also known as degree reduction of a polynomial?</strong></p>
<p>Assuming that we know a polynomial $P(x)$ and its value $y_1$ at $x_1$ï¼Œthat is $P(x_1) &#x3D; y_1$.</p>
<p>Now, consider a new polynomial $P(x) - y_1$, which has a value of zero at $( x &#x3D; x_1 )$ , because $P(x_1) - y_1 &#x3D; y_1 - y_1 &#x3D; 0$.</p>
<p>Tererfore, The polynomial $P(x) - y_1$has a root at $x &#x3D; x_1$ ï¼Œwhich means that $(x - x_1)$ is a factor of $P(x) - y_1$.</p>
<p>In other words, we can express it in the following form: $[ P(x) - y_1 &#x3D; (x - x_1)Q(x) ]$</p>
<p>$Q(x)$ is another polynomial whose degree is one less than that of $P(x)$. This is beacuse $(x - x_1)$ is a first-degree factor, which reduces the total degree of the polynomial.</p>
<p><strong>How to use KZG to prove a single value in a vector?</strong></p>
<p>Take the KZG10 commitment as an example, for the polynomial $P(x)$, suppose its polynomial commitment is $[P(s)]_1$.</p>
<p>As previously explained, for the polynomial $P(x)$, if $P(z)&#x3D;y$, then we have $Q(x)&#x3D;(P(x)-y)&#x2F;(x-z)$</p>
<p>Now, the prover can generate a proof that the polynomial $P(x)$ satisfies $P(z)&#x3D;y$: compute $[Q(s)]_1$and send it to the verifier.</p>
<p>The verifier needs to verify $e([Q(s)]_1,[s-z]_2)&#x3D;e([P(s)]_1-[y]_1,[1]_2)$.</p>
<p><strong>How to use KZG to prove multiple values in a vector?</strong></p>
<p>We can construct a proof to demonstrate multiple values in a vector as follows:</p>
<p>Suppose the verifier wants to prove that the polynomial $P(x)$ evaluates to $(z_0, z_1,\ldots,z_{k-1})$at points $(y_0, y_1,\ldots,y_{k-1})$.</p>
<p>Define two polynomials:</p>
<ul>
<li><p>$I(x) : I(z_i) = y_i \quad \text{for each } i \in [0, k]$</p>
</li>
<li><p>$V(x) = \prod_{i=0}^{k-1}(x - x_i)$</p>
</li>
</ul>
<p>In the same way, there exists a polynomial $Q(x)$ such that $Q(x) *V(x) &#x3D; P(x) - I(x)$.</p>
<p>The prover computes commitments for the polynomials $P(x)$ and $Q(x)$, denoted as $[P(s)]_1$ and $[Q(s)]_1$, and sends them as proof to the verifier. The verifier can locally compute $[I(s)]_1$ and $[V(s)]_2$ and then verify that $e([Q(s)]_1,[V(s)]_2) &#x3D; e([P(s)]_1 - [I(s)]_1, H)$.</p>
<p>By using this method, regardless of the number of data points in the same vector that need to be verified, only a proof of constant size is required.</p>
<p><strong>Now letâ€™s look at the Verkle Tree scheme without optimization from the perspective of the KZG commitment algorithm.</strong></p>
<p>Suppose the verifier wants to prove a set of polynomials $f_0(x),f_1(x),\ldots,f_{m-1}(x)$ satisfy the following at $(z_0, z_1,\ldots,z_{m-1})$: $f_i(z_i)&#x3D;y_i,\quad i \in [0, m-1]$</p>
<p>Using the construction method from the section â€œHow to use KZG to prove a single value in a vector,â€ the verifier can construct commitments for the original and quotient polynomials for each polynomial $f_i(x)$, resulting in a total of $2*m$ KZG commitments. The verifier sends all these commitments as proof for verification.</p>
<p>However, as mentioned earlier, this approach requires generating multiple proofs, and the verifier also needs to perform multiple verification computations. We need to find a way to compress multiple commitment proofs.</p>
<p><strong>Merging the Proofs</strong></p>
<p>The verifier first randomly generates a series of random numbers$(r_0, r_1,\ldots,r_{m-1})$, and then combines the aforementioned quotient polynomials together: $g(x) &#x3D; r_0q_0(z) + r_1q_1(z) + \ldots + r_{m-1}q_{m-1}(z)$. </p>
<p>Assume that $g(x)$ is a polynomial if and only if each quotient polynomial is indeed a polynomial. This is a reasonable assumption because the probability that the random numbers exactly cancel out all the coefficients of each term in all the quotient polynomials is very low. </p>
<p>The prover constructs a commitment $[g(s)]_1$ for $g(x)$ and sends it to the verifier. However, some commitments must also be constructed to convince the verifier that $[g(s)]_1$ is indeed a commitment to $g(x)$.</p>
<p>Let $g(x)&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{f_i(x)-y_i}{x-z_i}&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{f_i(x)}{x-z_i}-\sum_{i&#x3D;0}^{m-1}r_i\frac{y_i}{x-z_i}$</p>
<p>Randomly select a value t, substitute it in, and get:$g(t)&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{f_i(t)-y_i}{t-z_i}&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{f_i(t)}{t-z_i}-\sum_{i&#x3D;0}^{m-1}r_i\frac{y_i}{t-z_i}$</p>
<p>Next, define the following polynomial: $h(x)&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{f_i(x)}{t-z_i}$</p>
<p>The commitment to $h(x)$ can actually be expressed as $[h(s)]_1&#x3D;\sum_{i&#x3D;0}^{m-1}r_i \frac{C_i}{t-z_i}$ where $C_i$ is $[f_i(s)]1$. Because the polynomial $h(x)-g(x)$ at $x&#x3D;t$ has: $h(t)-g(t)&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{y_i}{t-z_i}$, a proof can be constructed for $h(x)-g(x)$ where at $x&#x3D;t$, $y&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{y_i}{t-z_i}$, with the corresponding quotient polynomial:$q(x)&#x3D;(h(x)-g(x)-y)&#x2F;(x-t)$.</p>
<p>The prover sends the proof $[q(s)]_1$ to the verifier for verification. </p>
<p>The evidence produced by this scheme consists of one commitment, two proofs, and one value, with constant data size. Eventually, after the proof merging optimization in the Verkle tree, the verifiable data object sent to the verifier includes the following:</p>
<ol>
<li>Constant size evidence</li>
<li>The data of the leaves to be proven (key-value pairs)</li>
<li>The commitment values of all nodes on the path from the leaf to the root (assuming a tree width of 256 with 2^32 nodes, then the average depth is 4, requiring only 3 commitment values)</li>
</ol>
<p>Note that $x_i$ and  $y_i$  do not need to be explicitly provided; they can all be computed.</p>
<h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3><p>Regarding the proof merging scheme for Verkle trees, the specific size of the generated proof is as followsï¼ˆThe unit of the row is billion.ï¼‰:<br><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/12.png" alt="image"></p>
<p>The above data assumes the usage of a tree of width 256, employing the KZG commitment scheme (with a commitment size of 48 bytes), and maximizes the utilization of the tree. In practice, for completely random distributions of information, the tree depth would increase by about 60%, and the size of each element would increase by 30 bytes. If the bulletproof scheme is used, then the commitment size would be 32 bytes.</p>
<h2 id="Prover-and-verifier-computation-load"><a href="#Prover-and-verifier-computation-load" class="headerlink" title="Prover and verifier computation load"></a>Prover and verifier computation load</h2><ol>
<li>Proof Generation: The cost of generating proofs by the prover is related to the treeâ€™s width, but each atomic operation requires a relatively low computational cost, so Verkle trees with widths between 256 and 1024 perform well in terms of algorithms.</li>
<li>Proof Verification: Vitalik has indicated that the verification algorithm is very fast and can typically be completed within 100ms, even when there are several thousand values to verify.</li>
<li>When Updating Verkle Trees: Updating the tree requires recalculating all the intermediate commitment values along the path due to changes in values or structure. However, Vitalik mentioned that, thanks to some properties of the polynomial commitment algorithm, it is possible to design a method that precomputes alternative commitment values and stores them, thereby reducing the computational time cost during updates, which essentially trades space for time.</li>
</ol>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><p>The following is the original words of vitalik blog, we added a paragraph at the end as a supplementã€‚</p>
<p>Verkle trees are a powerful upgrade to Merkle proofs that allow for much smaller proof sizes. Instead of needing to provide all â€œsister nodesâ€ at each level, the prover need only provide a single proof that proves all parent-child relationships between all commitments along the paths from each leaf node to the root. This allows proof sizes to decrease by a factor of ~6-8 compared to ideal Merkle trees, and by a factor of over 20-30 compared to the hexary Patricia trees that Ethereum uses today (!!).</p>
<p>They do require more complex cryptography to implement, but they present the opportunity for large gains to scalability. In the medium term, SNARKs can improve things further: we can either SNARK the already-efficient Verkle proof verifier to reduce witness size to near-zero, or switch back to SNARKed Merkle proofs if&#x2F;when SNARKs get much better (eg. through GKR, or very-SNARK-friendly hash functions, or ASICs). Further down the line, the rise of quantum computing will force a change to STARKed Merkle proofs with hashes as it makes the linear homomorphisms that Verkle trees depend on insecure. But for now, they give us the same scaling gains that we would get with such more advanced technologies, and we already have all the tools that we need to implement them efficiently.</p>
<p>At present, many Ethereum clients have provided the implementation of the Verkle tree and related test networks. The community is still discussing the time when the Verkle Trees will be launched on the main network. It is likely to be implemented in a hard fork upgrade in 2024 or 2025. For detailed information about Verkle trees on Ethereum, see <a href="https://verkle.info/" target="_blank" rel="noopener">https://verkle.info/</a> ã€‚</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1]. BRASSARD G, CHAUM D, CREÌPEAU C. Minimum disclosure proofs of knowledge[J].  Journal of computer and system sciences, 1988, 37(2): 156-189.</p>
<p>[2].  CATALANO D, FIORE D. Vector commitments and their applications[C]&#x2F;&#x2F;Public-KeyCryptographyâ€“PKC 2013: 16th International Conference on Practice and Theory in Public- Key Cryptography, Nara, Japan, February 26â€“March 1, 2013. Proceedings 16. Springer, 2013: 55-72.  </p>
<h1 id="About"><a href="#About" class="headerlink" title="About"></a>About</h1><h2 id="AntChain-Open-Labs"><a href="#AntChain-Open-Labs" class="headerlink" title="AntChain Open Labs"></a><strong>AntChain Open Labs</strong></h2><p>AntChain Open Labs is a research center initiated by AntChain and world leading computer scientists in the area of foundational trust technologies. It is dedicated to building a secure, transparent and reliable Web3 infrastructure driven by innovative research and aiming to advance transformative services.<br>Websiteï¼š<a href="https://openlabs-intl.antdigital.com/home" target="_blank" rel="noopener">https://openlabs-intl.antdigital.com/home</a>  </p>
<h2 id="ZAN"><a href="#ZAN" class="headerlink" title="ZAN"></a><strong>ZAN</strong></h2><p>ZAN, powered by AntChain Open Labs, provides solutions for Web3, such as Smart Contract Review, KYT, KYC, Node Service, and more.<br><a href="https://zan.top/home" target="_blank" rel="noopener">Website</a> | <a href="https://t.me/ZANTeam" target="_blank" rel="noopener">Telegram</a> | <a href="http://discord.gg/KucRCH9Mcb" target="_blank" rel="noopener">Discocd</a> |  <a href="https://x.com/zan_team" target="_blank" rel="noopener">Twitter</a> | <a href="https://linktr.ee/zan_team" target="_blank" rel="noopener">More</a></p>
<hr>
<h1 id="ä¸­æ–‡ç‰ˆ"><a href="#ä¸­æ–‡ç‰ˆ" class="headerlink" title="ä¸­æ–‡ç‰ˆ"></a>ä¸­æ–‡ç‰ˆ</h1><h1 id="å¼•è¨€"><a href="#å¼•è¨€" class="headerlink" title="å¼•è¨€"></a>å¼•è¨€</h1><p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/01.png" alt="image"></p>
<p>2023å¹´çš„æœ€åä¸€å¤©ï¼ŒVitalikåœ¨æ¨ç‰¹åˆ†äº«äº†2023å¹´çš„ä»¥å¤ªåŠè·¯çº¿å›¾ï¼Œå¯¹ä»¥å¤ªåŠåœ¨2023å¹´çš„è¿›å±•åšäº†æ€»ç»“ã€‚è·¯çº¿å›¾ä¸­The Vergeéƒ¨åˆ†æè¿°äº†å¦‚ä½•æ›´ç®€å•é«˜æ•ˆåœ°éªŒè¯åŒºå—é“¾çŠ¶æ€çš„ä»¥å¤ªåŠæŠ€æœ¯ã€‚å…¶ä¸­æœ‰ä¸ªæ ¸å¿ƒæ¦‚å¿µæ˜¯Verkleæ ‘(Verkle Trees)ï¼Œé‚£ä¹ˆä»€ä¹ˆæ˜¯Verkleæ ‘ï¼Œä¸ºä»€ä¹ˆéœ€è¦Verkleæ ‘ï¼Œå®ƒæ˜¯æ€ä¹ˆè§£å†³é—®é¢˜çš„ï¼Ÿæœ¬ç¯‡æ–‡ç« çš„ç›®æ ‡æ˜¯åœ¨ä¸æ¶‰åŠå¤ªå¤šå¯†ç å­¦å’Œæ•°å­¦ç­‰çŸ¥è¯†çš„æƒ…å†µä¸‹ä¸ºè¯»è€…å›ç­”ä»¥ä¸Šé—®é¢˜ï¼Œå¸®åŠ©å¯¹ä»¥å¤ªåŠæœ‰ä¸€å®šäº†è§£çš„è¯»è€…å¿«é€Ÿäº†è§£Verkleæ ‘ã€‚</p>
<h1 id="å¯éªŒè¯æŸ¥è¯¢æŠ€æœ¯"><a href="#å¯éªŒè¯æŸ¥è¯¢æŠ€æœ¯" class="headerlink" title="å¯éªŒè¯æŸ¥è¯¢æŠ€æœ¯"></a>å¯éªŒè¯æŸ¥è¯¢æŠ€æœ¯</h1><p>å¯éªŒè¯æŸ¥è¯¢æŠ€æœ¯åœ¨ä¼ ç»Ÿæ•°æ®åº“é¢†åŸŸç ”ç©¶å¹¿æ³›ï¼Œä¸»è¦ç”¨äºè§£å†³å¤–æºæ•°æ®åº“å­˜åœ¨çš„ä¿¡ä»»é—®é¢˜ã€‚åœ¨è®¸å¤šåœºæ™¯ä¸‹ï¼Œæ•°æ®çš„æ‰€æœ‰è€…å¯èƒ½ä¸ä¼šé€‰æ‹©è‡ªå·±å­˜å‚¨æ•°æ®ï¼Œè€Œæ˜¯å°†è‡ªèº«çš„æ•°æ®åº“éœ€æ±‚å§”æ‰˜ç»™ç¬¬ä¸‰æ–¹ï¼Œæ¥ä¸ºç”¨æˆ·æä¾›æ•°æ®åº“æœåŠ¡ï¼ˆå¦‚äº‘æ•°æ®åº“ï¼‰ï¼Œä½†ç”±äºç¬¬ä¸‰æ–¹ä¸æ€»æ˜¯å¯ä¿¡çš„ï¼Œå› æ­¤å…¶è¿”å›ç»™ç”¨æˆ·çš„æŸ¥è¯¢ç»“æœçš„å¯ä¿¡æ€§éš¾ä»¥ä¿è¯ã€‚ å½“å‰ä¼ ç»Ÿæ•°æ®åº“çš„å¯éªŒè¯æŸ¥è¯¢æ–¹æ¡ˆä¸»è¦æœ‰ä¸¤ç§ï¼šåŸºäºADSï¼ˆAuthenticated Data Structureï¼‰çš„æ–¹æ¡ˆå’ŒåŸºäºå¯éªŒè¯è®¡ç®—çš„æ–¹æ¡ˆã€‚</p>
<p>ADS æ˜¯å¹¿æ³›ç”¨äºä¼ ç»Ÿæ•°æ®åº“çš„å¯éªŒè¯æŸ¥è¯¢æŠ€æœ¯ï¼Œå¤šæ•°åŸºäº Merkle æ ‘æˆ–ç±»ä¼¼å…·æœ‰ç´¯åŠ åŠŸèƒ½çš„ç»“æ„æ„å»ºã€‚éšç€å¯†ç å­¦å·¥å…·çš„å‘å±•ï¼Œè®¸å¤šç ”ç©¶è€…é€æ¸å¼€å§‹æ¢ç´¢é€šè¿‡å¯éªŒè¯è®¡ç®—æŠ€æœ¯æ¥è§£å†³æŸ¥è¯¢ä¸å¯ä¿¡çš„é—®é¢˜ã€‚ä¸€äº›åŸºäºé›¶çŸ¥è¯†è¯æ˜åè®® SNARKsçš„å¯éªŒè¯è®¡ç®—æ–¹æ¡ˆå¯é—´æ¥ç”¨äºæ”¯æŒå¤–æºæ•°æ®åº“çš„å¯éªŒè¯æŸ¥è¯¢ï¼Œè¿™äº›æ–¹æ¡ˆå¯æ”¯æŒçš„æŸ¥è¯¢ç±»å‹ä¸°å¯Œï¼Œä¸”äº§ç”Ÿçš„éªŒè¯ä¿¡æ¯è¾ƒå°‘ï¼Œä½†å…¶è®¡ç®—å¼€é”€è¾ƒå¤§ã€‚</p>
<p>ç›®å‰çš„ä»¥å¤ªåŠåˆ©ç”¨Merkleæ ‘æ¥å®ç°å¯éªŒè¯æŸ¥è¯¢ï¼Œè€ŒVerkleæ ‘æŠ€æœ¯ä¹ŸåŸºäºMerkleæ ‘æŠ€æœ¯ã€‚æ‰€ä»¥æ¥ä¸‹æ¥å…ˆä»‹ç»Merkleæ ‘ï¼Œä»¥å…¶ä¸ºä¾‹å­æ¥å¸®åŠ©è¯»è€…ç†è§£å¯éªŒè¯æŸ¥è¯¢çš„ä½œç”¨ã€‚</p>
<h1 id="Merkleæ ‘"><a href="#Merkleæ ‘" class="headerlink" title="Merkleæ ‘"></a>Merkleæ ‘</h1><h2 id="Merkleæ ‘çš„å®šä¹‰å’Œç‰¹å¾"><a href="#Merkleæ ‘çš„å®šä¹‰å’Œç‰¹å¾" class="headerlink" title="Merkleæ ‘çš„å®šä¹‰å’Œç‰¹å¾"></a>Merkleæ ‘çš„å®šä¹‰å’Œç‰¹å¾</h2><p>Merkleæ ‘æ˜¯ä¸€ä¸ªåœ¨å¯†ç å­¦ä¸­å¸¸ä½¿ç”¨çš„æ ‘å½¢ç»“æ„ï¼Œé€‚ç”¨äºè§£å†³æ•°æ®å®Œæ•´æ€§é—®é¢˜ã€‚ ä»¥ä¸‹æ˜¯ä¸€ä¸ªå…¸å‹çš„Merkleæ ‘ç»“æ„ï¼Œå¶å­èŠ‚ç‚¹ä¸ºåŸæ•°æ®æˆ–è€…å…¶å“ˆå¸Œå€¼ï¼Œæ¯ä¸ªéå¶å­èŠ‚ç‚¹ä¸ºå…¶å­èŠ‚ç‚¹å…±åŒçš„å“ˆå¸Œå€¼ã€‚</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/02.png" alt="image"></p>
<p>Merkleæ ‘çš„<strong>é‡è¦ç‰¹å¾</strong>æœ‰ä¸¤ç‚¹ï¼š</p>
<ol>
<li>é˜²æ­¢æ•°æ®ç¯¡æ”¹ ã€‚Merkle æ ‘æ„å»ºæ—¶ä¸€èˆ¬é‡‡ç”¨æŠ—ç¢°æ’çš„å“ˆå¸Œå‡½æ•°ï¼Œä½¿ç”¨è¿™ç§å“ˆå¸Œå‡½æ•°æ‰¾åˆ°ä¸¤ä¸ªæ‹¥æœ‰ç›¸åŒå“ˆå¸Œå€¼çš„æ¶ˆæ¯åœ¨è®¡ç®—ä¸Šæ˜¯å‡ ä¹ä¸å¯è¡Œçš„ï¼Œä» Merkle æ ‘çš„ç»“æ„å¯ä»¥çœ‹åˆ°ï¼Œå¯¹ä»»æ„å¶å­ç»“ç‚¹ä¸­äº¤æ˜“æ•°æ®çš„ä¿®æ”¹ï¼Œéƒ½å°†å¯¼è‡´æ ‘æ ¹å“ˆå¸Œå€¼çš„å˜åŒ– ã€‚</li>
<li>æ”¯æŒé«˜æ•ˆéªŒè¯å¤§é‡æ•°æ®çš„å®Œæ•´æ€§ã€‚éªŒè¯è€…ä»…éœ€ä¿å­˜ Merkle æ ‘çš„æ ‘æ ¹å“ˆå¸Œå€¼ï¼Œå³å¯é€šè¿‡å¶èŠ‚ç‚¹åˆ°æ ‘æ ¹è·¯å¾„ä¸Šçš„å…„å¼ŸèŠ‚ç‚¹æ¥éªŒè¯ä»»æ„æ•°æ®çš„å®Œæ•´æ€§ï¼Œè€Œæ— éœ€ä¼ è¾“å®Œæ•´çš„æ•°æ®ï¼Œè¿™äº›å¯ä»¥ç”¨æ¥é‡æ„æ ‘æ ¹å“ˆå¸Œçš„å…„å¼ŸèŠ‚ç‚¹è¢«ç§°ä¸º Merkle è·¯å¾„(Merkle Path)</li>
</ol>
<h2 id="æ€ä¹ˆæ„å»ºMerkleè¯æ˜ï¼Ÿ"><a href="#æ€ä¹ˆæ„å»ºMerkleè¯æ˜ï¼Ÿ" class="headerlink" title="æ€ä¹ˆæ„å»ºMerkleè¯æ˜ï¼Ÿ"></a>æ€ä¹ˆæ„å»ºMerkleè¯æ˜ï¼Ÿ</h2><p>ä¸€ä¸ªæ™®éçš„å¯éªŒè¯æŸ¥è¯¢åœºæ™¯ä¸­æœ‰è¯æ˜è€…ï¼ˆProverï¼‰å’ŒéªŒè¯è€…ï¼ˆVerifierï¼‰ï¼Œè¯æ˜è€…éœ€è¦ç”Ÿæˆè¯æ˜å¹¶å‘é€ç»™éªŒè¯è€…ã€‚å¯¹åº”åˆ°ä»¥å¤ªåŠç½‘ç»œä¸­ï¼Œä¸€ä¸ªå…¸å‹çš„åº”ç”¨åœºæ™¯æ˜¯è½»èŠ‚ç‚¹ï¼ˆåªä¿å­˜åŒºå—å¤´çš„å®¢æˆ·ç«¯ï¼‰å‘å…¨èŠ‚ç‚¹æˆ–è€…å½’æ¡£èŠ‚ç‚¹ï¼ˆæ‹¥æœ‰å…¨éƒ¨æ•°æ®çš„å®¢æˆ·ç«¯ï¼‰æŸ¥è¯¢äº¤æ˜“æ•°æ®ï¼Œå¹¶è·å–Merkleè¯æ˜åœ¨æœ¬åœ°éªŒè¯æŸ¥è¯¢ç»“æœæ˜¯å¦æ­£ç¡®ã€‚</p>
<p>Merkleè¯æ˜ç»„æˆæœ‰ä»¥ä¸‹3éƒ¨ä»½ï¼š</p>
<ol>
<li>å®Œæ•´æ•°æ®é›†çš„Merkleæ ‘æ ¹å“ˆå¸Œ</li>
<li>éœ€è¦è¢«è¯æ˜å®Œæ•´æ€§çš„æ•°æ®å—</li>
<li>Merkleè·¯å¾„ï¼Œå³ä»å¶èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹è·¯å¾„ä¸Šçš„æ‰€æœ‰å…„å¼ŸèŠ‚ç‚¹çš„å€¼ã€‚</li>
</ol>
<p>å…¶ä¸­Merkleæ ‘æ ¹å“ˆå¸Œéœ€è¦é€šè¿‡ä¸€ç§å¯ä¿¡çš„æ‰‹æ®µæå‰å‘é€ç»™éªŒè¯è€…ï¼Œå¹¶è®©éªŒè¯è€…ä¿¡ä»»è¿™ä¸ªå€¼ã€‚ä»¥å¤ªåŠä¸­é€šè¿‡å…±è¯†ç®—æ³•ä¿è¯äº†åŒºå—æ•°æ®çš„å¯ä¿¡ï¼ŒMerkleæ ‘æ ¹å“ˆå¸Œå­˜åœ¨äºåŒºå—å¤´ä¸­ã€‚</p>
<p>ä¸‹å›¾æ˜¯ä¸€ä¸ªå…·ä½“çš„ä¾‹å­ï¼Œå½“è¯æ˜è€…éœ€è¦å‘éªŒè¯è€…è¯æ˜â€œ4â€æ˜¯å­˜åœ¨äºè¿™ä¸ªæ•°æ®é›†åˆä¸­çš„æ•°æ®å—æ—¶ï¼ŒéªŒè¯è€…æŒæœ‰å¯ä¿¡çš„å®Œæ•´æ•°æ®çš„Merkleæ ‘æ ¹å“ˆå¸Œâ€œ1d25â€ï¼Œé‚£ä¹ˆè¯æ˜è€…åªéœ€æä¾›æ‰€æœ‰æ ‡è“çš„æ•°æ®å³å¯ã€‚å‡è®¾é›†åˆä¸­æœ‰næ¡æ•°æ®ï¼Œåˆ™æœ€å¤šåªéœ€$log_2(n)$æ¬¡å“ˆå¸Œè®¡ç®—å³å¯éªŒè¯ä»»æ„æ•°æ®æ®µçš„æ­£ç¡®æ€§ã€‚</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/03.png" alt="image"></p>
<p>ä»¥å¤ªåŠçš„è½»èŠ‚ç‚¹åªåŒæ­¥åŒºå—å¤´ï¼ŒåŒºå—å¤´ä¸­åŒ…å«å¤šä¸ªæ•°æ®çš„Merkleæ ‘çš„æ ¹ï¼ˆçŠ¶æ€æ ‘ã€äº¤æ˜“æ ‘ã€æ”¶æ®æ ‘ï¼‰ã€‚åœ¨è½»èŠ‚ç‚¹å‘å…¨èŠ‚ç‚¹æŸ¥è¯¢æ ‘çš„æŸä¸ªå¶èŠ‚ç‚¹æ•°æ®æ—¶ï¼Œå…¨èŠ‚ç‚¹è¿”å›åŸæ•°æ®ä»¥åŠå¯¹åº”çš„MerkleéªŒè¯è·¯å¾„ï¼Œè½»èŠ‚ç‚¹å°±å¯ä»¥ä¿¡ä»»æŸ¥è¯¢ç»“æœçš„æ­£ç¡®æ€§ã€‚</p>
<h2 id="Merkleæ ‘çš„å˜ç§"><a href="#Merkleæ ‘çš„å˜ç§" class="headerlink" title="Merkleæ ‘çš„å˜ç§"></a>Merkleæ ‘çš„å˜ç§</h2><p>åœ¨Merkleæ ‘çš„åŸºç¡€ä¸Šï¼Œæ ¹æ®å…¶å®ƒç›®çš„ï¼Œå¯ä»¥æŠŠMerkleæ ‘å’Œå…¶å®ƒæ•°æ®ç»“æ„åˆå¹¶æ”¹é€ ä»è€Œå®ç°æ–°çš„ç‰¹æ€§ã€‚é’ˆå¯¹å„ç§ä¸åŒçš„å¯éªŒè¯æŸ¥è¯¢åœºæ™¯ï¼ŒMerkleæ ‘å¯ä»¥è¢«æ‹“å±•åˆ°å„ç§ç´¢å¼•æ•°æ®ç»“æ„ä¸Šï¼Œä¾‹å¦‚Merkle-Bæ ‘ï¼ˆMBTï¼‰ã€‚ä¸ºäº†é«˜æ•ˆå®Œæˆæ’å…¥ã€åˆ é™¤ã€æŸ¥è¯¢ç­‰æ“ä½œï¼Œä»¥å¤ªåŠå›¢é˜Ÿæå‡ºäº†Merkle Patriciaæ ‘ï¼ˆMPTï¼‰ã€‚</p>
<h3 id="Merkle-B-Tree-1"><a href="#Merkle-B-Tree-1" class="headerlink" title="Merkle-B Tree"></a>Merkle-B Tree</h3><p>Merkle-B Treeä¸»è¦ç”¨äºå¤„ç†å¯éªŒè¯çš„èŒƒå›´æŸ¥è¯¢ã€‚è®¾ ğ‘“ ä¸º MBT çš„æ‰‡å‡ºï¼ˆèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡ï¼‰ï¼Œåœ¨ B+ æ ‘çš„åŸºç¡€ä¸Šï¼ŒMBT çš„æ¯ä¸ªä¸­é—´èŠ‚ç‚¹é™¤äº†ä¿å­˜ ğ‘“ âˆ’ 1 ä¸ªç´¢å¼•å…³é”®å­—å’Œ ğ‘“ ä¸ªå­èŠ‚ç‚¹çš„æŒ‡é’ˆå¤–ï¼Œè¿˜ä¼šä»¥æ‘˜è¦çš„å½¢å¼ä¿å­˜æ‰€æœ‰å­èŠ‚ç‚¹çš„å“ˆå¸Œå€¼ã€‚ä¸‹å›¾ä¸ºMBTçš„å¶å­èŠ‚ç‚¹å’Œä¸­é—´èŠ‚ç‚¹çš„ç»“æ„ã€‚</p>
<p>å½“éœ€è¦è¯æ˜æŸæ¬¡èŒƒå›´æŸ¥è¯¢è¿”å›çš„æ•°æ®æ˜¯ç¬¦åˆèŒƒå›´ï¼Œè®¡ç®—VO(Verification Object )çš„æœåŠ¡å™¨éœ€è¦å…ˆæ‰§è¡Œä¸¤æ¬¡è‡ªä¸Šè€Œä¸‹çš„æœç´¢æ“ä½œæ‰¾åˆ°å·¦å³è¾¹ç•Œï¼Œå¹¶ä¸”è¿”å›è¿™ä¸ªè¾¹ç•Œçš„æ‰€æœ‰æ•°æ®ï¼Œä»¥åŠæ„é€ åˆ°æ ¹å“ˆå¸Œè¿‡ç¨‹ä¸­æ‰€æœ‰éœ€è¦çš„æ—æçš„å“ˆå¸Œå€¼ã€‚</p>
<p>è¿™ç§æ•°æ®ç»“æ„çš„ç¼ºç‚¹æ˜¯è¿”å›çš„VOåªèƒ½è¯æ˜æŸ¥è¯¢ç»“æœåœ¨è¦æ±‚çš„æŸ¥è¯¢èŒƒå›´å†…ï¼Œä½†æ˜¯ä¸èƒ½è¯æ˜è¿”å›ç»“æœæ˜¯å®Œæ•´çš„ã€‚</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/04.png" alt="image"></p>
<h3 id="Merkle-Patricia-Tree-1"><a href="#Merkle-Patricia-Tree-1" class="headerlink" title="Merkle Patricia Tree"></a>Merkle Patricia Tree</h3><p>å¦‚æœç®€å•åœ°ä½¿ç”¨æœ´ç´ çš„Merkle Treeæ¥æä¾›å¯éªŒè¯æŸ¥è¯¢ï¼Œéšç€æ•°æ®çš„æ’å…¥æˆ–è€…åˆ é™¤ï¼Œæ¯æ¬¡é‡æ–°ç”ŸæˆMerkleæ ‘æ ¹éƒ½éœ€è¦å¤§é‡çš„æ—¶é—´ï¼ŒåŒæ—¶è¿˜éœ€è¦æ¶ˆè€—å­˜å‚¨ç»´æŠ¤é¢å¤–çš„æ•°æ®æœç´¢æ ‘ã€‚Merkle Patricia Treeï¼ˆMPTï¼‰ç»“åˆäº†Redix Treeï¼ˆå‹ç¼©å‰ç¼€æ ‘ï¼‰å’ŒMerkleæ ‘ï¼Œå¯ä»¥æä¾›O(log(N))æ—¶é—´æ‰§è¡Œæ’å…¥ã€åˆ é™¤ã€æŸ¥è¯¢ç­‰æ“ä½œã€‚å…³äºMPTçš„å…¨éƒ¨ç»†èŠ‚ï¼Œè¯»è€…å¯ä»¥å¦å¤–æŸ¥è¯¢ä¸“ä¸šçš„MPTæŠ€æœ¯æ–‡ç« ï¼Œæœ¬æ–‡åªä»‹ç»ä¸€äº›åŸºç¡€å®šä¹‰ï¼Œå¹¶ä¸¾ä¾‹æ¥å¸®åŠ©è¯»è€…å¿«é€Ÿç†è§£MPTã€‚</p>
<p>ä»¥å¤ªåŠçš„åº•å±‚é‡‡ç”¨é”®å€¼æ•°æ®åº“æ¥å­˜å‚¨æ•°æ®åº“ï¼Œå³æ•°æ®ä»¥é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨ï¼ŒMPTä¹Ÿè¢«æ‹†è§£ä¸ºé”®å€¼å¯¹è¿›è¡Œå­˜å‚¨ã€‚æˆ‘ä»¬å®šä¹‰MPTçš„èŠ‚ç‚¹é€»è¾‘ç»“æ„å¦‚ä¸‹ï¼š</p>
<ul>
<li>ç´¢å¼•</li>
<li>è·¯å¾„</li>
<li>æ•°æ®</li>
</ul>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/05.png" alt="image"></p>
<p>å…¶ä¸­â€œç´¢å¼•â€ä¸ºé”®å€¼å¯¹çš„é”®ï¼Œâ€œè·¯å¾„â€+â€œæ•°æ®â€æ„æˆé”®å€¼å¯¹çš„å€¼ã€‚ç´¢å¼•å®é™…å­˜å‚¨çš„æ˜¯Merkleæ ‘èŠ‚ç‚¹çš„å“ˆå¸Œï¼Œè·¯å¾„å¯¹åº”å‰ç¼€æ ‘ä¸­ç”¨æ¥å¯»æ‰¾ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„å­—ç¬¦ä¸²ï¼Œä»¥å¤ªåŠä½¿ç”¨åå…­è¿›åˆ¶å­—ç¬¦ä¸²ä½œä¸ºè·¯å¾„å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥MPTæ ‘çš„å®½åº¦ä¸º16ã€‚æ•°æ®åˆ™ä¸ºè·¯å¾„å¯¹åº”çš„ç›®æ ‡æ•°æ®ã€‚</p>
<p>ä»¥ä¸‹ä¸ºä¸€ä¸ªç»è¿‡å‹ç¼©å‰ç¼€ä¼˜åŒ–åçš„MPTä¾‹å­ï¼Œå…¶ä¸­å­˜å‚¨äº†å¦‚ä¸‹é”®å€¼å¯¹æ•°æ®</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  &#x27;cab8&#x27;<span class="punctuation">:</span> &#x27;dog&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;cabe&#x27;<span class="punctuation">:</span> &#x27;cat&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;<span class="number">39</span>&#x27;<span class="punctuation">:</span> &#x27;chicken&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;<span class="number">395</span>&#x27;<span class="punctuation">:</span> &#x27;duck&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;<span class="number">56</span>f0&#x27;<span class="punctuation">:</span> &#x27;horse&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/06.png" alt="image"></p>
<p>ä»¥é€šè¿‡â€œ395â€å¯»æ‰¾â€œduckâ€ä¸ºä¾‹ï¼Œä»æ ¹å“ˆå¸Œï¼Œç»è¿‡hashAã€hashCã€hashDæœ€ç»ˆæ‰¾åˆ°ç›®æ ‡æ•°æ®ã€‚</p>
<h1 id="å‘é‡æ‰¿è¯º"><a href="#å‘é‡æ‰¿è¯º" class="headerlink" title="å‘é‡æ‰¿è¯º"></a>å‘é‡æ‰¿è¯º</h1><p>æ‰¿è¯ºï¼ˆCommitmentï¼‰[1]æ˜¯ä¸€ä¸ªå¯†ç å­¦åŸè¯­ï¼Œæ˜¯ä¸€ç§ç”¨äºä¿è¯æ•°æ®ç§å¯†æ€§å’Œå®Œæ•´æ€§çš„æŠ€æœ¯ï¼Œè¢«å¹¿æ³›åº”ç”¨äºé›¶çŸ¥è¯†è¯æ˜ã€å®‰å…¨å¤šæ–¹è®¡ç®—ç­‰åœºæ™¯ä¸­ã€‚ä¸€ä¸ªåŸºç¡€çš„æ‰¿è¯ºæ–¹æ¡ˆåˆ†ä¸º2ä¸ªé˜¶æ®µï¼šæ‰¿è¯ºé˜¶æ®µå’Œæ‰“å¼€é˜¶æ®µã€‚</p>
<ol>
<li>æ‰¿è¯ºé˜¶æ®µï¼Œæ‰¿è¯ºè€…ä½¿ç”¨åŠ å¯†ç®—æ³•å°†æ¶ˆæ¯ç»‘å®šåˆ°ä¸€ä¸ªæ‰¿è¯ºå€¼ä¸Šï¼Œå¹¶å°†æ­¤æ‰¿è¯ºå€¼å‘é€ç»™æ¥å—è€…ã€‚åœ¨è¿™ä¸€é˜¶æ®µï¼Œæ‰¿è¯ºå…·æœ‰éšè—æ€§å’Œç»‘å®šæ€§ã€‚éšè—æ€§æ˜¯æŒ‡åœ¨å½“å‰é˜¶æ®µï¼Œé™¤æ‰¿è¯ºè€…ä¹‹å¤–æ²¡äººçŸ¥é“è¢«æ‰¿è¯ºçš„æ¶ˆæ¯å†…å®¹ã€‚ç»‘å®šæ€§æ˜¯æŒ‡æ‰¿è¯ºè€…ä¸€æ—¦æäº¤æ‰¿è¯ºï¼Œä»»ä½•äººéƒ½æ— æ³•æ”¹å˜æ‰¿è¯ºçš„æ¶ˆæ¯ã€‚</li>
<li>æ‰“å¼€é˜¶æ®µï¼Œæ‰¿è¯ºè€…å¯ä»¥ä½¿ç”¨æ‰“å¼€ç®—æ³•å‘æ¥å—è€…è¯æ˜ï¼Œå‘é€ç»™ä»–çš„æ‰¿è¯ºå€¼æ˜¯å¯¹åŸæ¶ˆæ¯çš„ä¸€ä¸ªæœ‰æ•ˆæ‰¿è¯ºã€‚æ‰¿è¯ºå…·æœ‰æ­£ç¡®æ€§ï¼Œå³å¦‚æœæ‰¿è¯ºè€…å’Œæ¥å—è€…éƒ½æ­£ç¡®å±¥è¡Œåè®®ï¼Œ æ¥å—è€…åœ¨æ‰“å¼€é˜¶æ®µä¼šç¡®ä¿¡ä»–æ¥æ”¶åˆ°çš„æ‰¿è¯ºå€¼æ˜¯å¯¹åŸæ¶ˆæ¯çš„æœ‰æ•ˆæ‰¿è¯ºã€‚</li>
</ol>
<p>å‘é‡æ‰¿è¯ºï¼ˆVector Commitment ï¼‰æ˜¯ä¸€ç§ç”± Catalano ç­‰äººæå‡ºçš„ç‰¹æ®Šæ‰¿è¯ºæ–¹æ¡ˆ[2]ï¼Œå®ƒå…è®¸æ‰¿è¯ºè€…å¯¹ä¸€ç»„æœ‰åºçš„æ¶ˆæ¯ ğ‘š &#x3D; âŸ¨ğ‘š1 , ğ‘š2 , â€¦, ğ‘šğ‘ âŸ© è¿›è¡Œæ‰¿è¯ºï¼Œå¹¶åœ¨ä»»æ„çš„æŒ‡å®šä½ç½®æ‰“å¼€ï¼Œä»¥è¯æ˜æ¶ˆæ¯ ğ‘šğ‘– æ˜¯ç¬¬ i ä¸ªè¢«æ‰¿è¯ºçš„æ¶ˆæ¯ã€‚åœ¨å‘é‡æ‰¿è¯ºä¸­ï¼Œç»‘å®šæ€§æ„å‘³ç€ä»»ä½•äººéƒ½æ— æ³•åœ¨åŒä¸€ä¸ªä½ç½®æ‰“å¼€å¾—åˆ°ä¸åŒçš„æ¶ˆæ¯ã€‚ä¸€ä¸ªå‘é‡æ‰¿è¯ºç®—æ³•é€šå¸¸ç”±ä»¥ä¸‹ç®—æ³•ç»„æˆï¼š</p>
<ul>
<li>$Gen(1^Î»,q)â†’pp$,å¯†é’¥ç”Ÿæˆç®—æ³•ï¼Œåœ¨è¾“å…¥å®‰å…¨å‚æ•° Î» å’Œå‘é‡é•¿åº¦ ğ‘ åï¼Œè¾“ å‡ºå…¬å…±å‚æ•° ğ‘ğ‘ï¼›</li>
<li>$Commit(pp,<m_1,m_2,...,m_q>)â†’(C,aux)$,æ‰¿è¯ºç®—æ³•ï¼Œåœ¨è¾“å…¥å…¬å…±å‚æ•°å’Œ ğ‘ ä¸ªæ¶ˆæ¯æ„æˆçš„å‘é‡åï¼Œè¾“å‡ºæ‰¿è¯º C å’Œè¾…åŠ©ä¿¡æ¯ auxï¼›</li>
<li>$Open(pp,i,m_i,C,aux)â†’Ï€$ï¼Œè¯æ˜ç”Ÿæˆç®—æ³•ï¼Œè¾“å…¥å…¬å…±å‚æ•° ğ‘ğ‘ å’Œç›¸å…³ä¿¡ æ¯ï¼Œå½“ä¸”ä»…å½“ ğ‘šğ‘– æ˜¯æ¶ˆæ¯å‘é‡ä¸­çš„ç¬¬ ğ‘– ä¸ªæ¶ˆæ¯æ—¶ï¼Œè¯¥ç®—æ³•é€šè¿‡æ‰¿è¯º ğ¶ å’Œè¾…åŠ© ä¿¡æ¯ ğ‘ğ‘¢ğ‘¥ ç”Ÿæˆä¸€ä¸ªè¯æ˜ ğœ‹ï¼›</li>
<li>$Verify(pp,C,i,m,Ï€)â†’{accept \ or\  reject}$,éªŒè¯ç®—æ³•ï¼Œè¾“å…¥å…¬å…±å‚æ•° ğ‘ğ‘ã€æ‰¿è¯º ğ¶ã€æ¶ˆæ¯ ğ‘š å’Œä½ç½® ğ‘–ï¼Œä»¥åŠè¯æ˜ ğœ‹ï¼Œå½“ä¸”ä»…å½“æ¶ˆæ¯ ğ‘š æ˜¯åŸå‘é‡ä¸­çš„ç¬¬ i ä¸ªæ¶ˆ æ¯æ—¶ï¼Œğœ‹ é€šè¿‡éªŒè¯ï¼Œè¾“å‡º acceptï¼Œå¦åˆ™è¾“å‡º rejectã€‚</li>
</ul>
<h1 id="Verkle-Tree"><a href="#Verkle-Tree" class="headerlink" title="Verkle Tree"></a>Verkle Tree</h1><h2 id="Verkleæ ‘çš„å®šä¹‰å’Œç‰¹å¾"><a href="#Verkleæ ‘çš„å®šä¹‰å’Œç‰¹å¾" class="headerlink" title="Verkleæ ‘çš„å®šä¹‰å’Œç‰¹å¾"></a>Verkleæ ‘çš„å®šä¹‰å’Œç‰¹å¾</h2><p><strong>å®šä¹‰ï¼šVerkle Trees</strong> &#x3D; <strong>V</strong>ector Commitments + M<strong>erkle Trees</strong>ã€‚</p>
<p><strong>è¯´æ˜ï¼š</strong>Vitalikæœ‰ä¸€ç¯‡ä¸“é—¨ä»‹ç»Verkleæ ‘çš„åšå®¢ï¼Œæœ¬æ–‡åœ¨å…¶åŸºç¡€ä¸Šå¢åŠ ä¸€äº›å¯¹æ•°å­¦å’ŒèƒŒæ™¯çŸ¥è¯†çš„è¡¥å……ï¼Œä¸‹æ–‡éƒ¨åˆ†æ•°æ®å’Œå›¾ä¾‹æ¥è‡ªå…¶åšå®¢<a href="https://vitalik.eth.limo/general/2021/06/18/verkle.html" target="_blank" rel="noopener">Verkle trees</a>ã€‚</p>
<p>Verkleæ ‘ï¼ˆVTï¼‰çš„ç‰¹å¾æ˜¯æä¾›æ¯”Merkle æ ‘æ›´å°çš„è¯æ˜ã€‚å¯¹äºåäº¿çº§åˆ«çš„æ•°æ®ï¼ŒMerkleæ ‘ç”Ÿæˆçš„è¯æ˜å¤§æ¦‚æ˜¯1KBï¼Œè€ŒVerkle æ ‘ç”Ÿæˆçš„è¯æ˜ä¼šä¸åˆ°150Bã€‚è¿™æœ‰åˆ©äºå®ç°â€œ<a href="https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/stateless-clients/" target="_blank" rel="noopener">stateless clients </a>â€ã€‚</p>
<p>Verkle æ ‘çš„ç»“æ„å’ŒMPTå¾ˆç±»ä¼¼ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªä¾‹å­ã€‚å…¶èŠ‚ç‚¹è¦ä¹ˆæ˜¯ (i) ç©ºçš„ï¼Œè¦ä¹ˆæ˜¯ (ii) ä¸€ä¸ªå¶å­èŠ‚ç‚¹ï¼ŒåŒ…å«ä¸€ä¸ªé”®å’Œå¯¹åº”çš„å€¼ï¼Œæˆ–è€…æ˜¯ (iii) ä¸€ä¸ªä¸­é—´èŠ‚ç‚¹ï¼Œæ‹¥æœ‰å›ºå®šæ•°é‡ä¸ªå­èŠ‚ç‚¹ï¼ˆè¿™ä¸ªæ•°é‡ä¹Ÿå³æ˜¯æ ‘çš„ â€œå®½åº¦â€ï¼‰ã€‚</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/07.png" alt="image"></p>
<p>VTå’ŒMPTçš„åŒºåˆ«æ˜¯ï¼ŒMPTçš„å®½åº¦ï¼ˆæˆ–è€…æ‰‡å‡ºï¼ŒæŒ‡æ ‘ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡ï¼‰å¦‚æœè¶Šå¤§ï¼Œå…¶æ•ˆç‡è¶Šä½ï¼Œå› ä¸ºå®½åº¦è¶Šå¤§æ„å‘³ç€å…„å¼ŸèŠ‚ç‚¹è¶Šå¤šï¼Œå¯èƒ½ä¼šå¯¼è‡´æ›´æ–°MPTçš„æ—¶é—´å˜é•¿å’Œç”Ÿæˆçš„è¯æ˜å¤§å°å˜å¤§ï¼›ç›¸åçš„ï¼ŒVTçš„å®½åº¦è¶Šå®½ï¼Œå…¶ç”Ÿæˆçš„è¯æ˜å°±è¶Šå°ã€‚å”¯ä¸€çš„é™åˆ¶æ˜¯å¦‚æœå®½åº¦è¿‡é«˜ï¼Œç”Ÿæˆè¯æ˜çš„æ—¶é—´ä¼šæ¯”è¾ƒé•¿ã€‚ä»¥å¤ªåŠå…³äºVTçš„<a href="https://notes.ethereum.org/@vbuterin/verkle_tree_eip" target="_blank" rel="noopener">è®¾è®¡ææ¡ˆ</a>ä¸­å°±å»ºè®®å®½åº¦ä¸º256ï¼Œè¿œè¶…MPTç›®å‰çš„16ã€‚åæ–‡ä¼šå¯¹ä»¥ä¸Šç‰¹å¾åšè§£é‡Šã€‚</p>
<h2 id="Verkleæ ‘çš„æ‰¿è¯ºå’Œè¯æ˜"><a href="#Verkleæ ‘çš„æ‰¿è¯ºå’Œè¯æ˜" class="headerlink" title="Verkleæ ‘çš„æ‰¿è¯ºå’Œè¯æ˜"></a>Verkleæ ‘çš„æ‰¿è¯ºå’Œè¯æ˜</h2><p>å…ˆçœ‹çœ‹MPTæ˜¯æ€ä¹ˆç”Ÿæˆè¯æ˜çš„ï¼šè¯æ˜ä¸­éœ€è¦åŒ…å«æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡å¶å­èŠ‚ç‚¹è·¯å¾„ä¸Šçš„æ‰€æœ‰æ—è·¯èŠ‚ç‚¹ï¼ˆå…„å¼ŸèŠ‚ç‚¹ï¼‰çš„å“ˆå¸Œå€¼ã€‚ä»¥4ceä¸ºä¾‹ï¼Œä¸‹å›¾ä¸­ç”»çº¢çš„éƒ¨åˆ†å³éœ€è¦è¿”å›æ‰€åŒ…å«çš„èŠ‚ç‚¹ã€‚</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/08.png" alt="image"></p>
<p><strong>è€Œåœ¨Verkleæ ‘ä¸Šï¼Œä½ ä¸éœ€è¦æä¾›å…„å¼ŸèŠ‚ç‚¹ï¼›ç›¸åï¼Œä½ åªéœ€è¦æä¾›è·¯å¾„ï¼Œå†åŠ ä¸€äº›é¢å¤–çš„æ•°æ®ä½œä¸ºè¯æ®ã€‚</strong></p>
<p><strong>é‚£ä¹ˆå¦‚ä½•ä¸ºVTç”Ÿæˆæ‰¿è¯ºå‘¢ï¼Ÿ</strong>è¿™æ—¶å€™ç”¨æ¥è®¡ç®—çš„å“ˆå¸Œå‡½æ•°ä¸æ˜¯å¸¸è§„çš„å“ˆå¸Œï¼Œè€Œæ˜¯ä½¿ç”¨å‘é‡æ‰¿è¯ºã€‚</p>
<p>å°†å“ˆå¸Œå‡½æ•°æ›¿æ¢ä¸ºå‘é‡æ‰¿è¯ºçš„æ‰¿è¯ºç”Ÿæˆç®—æ³•ä¹‹åï¼Œé‚£ä¹ˆæ‰€è°“çš„æ ¹å“ˆå¸Œå°±æ˜¯æ ¹æ‰¿è¯ºäº†ã€‚å¦‚æœæ¯ä¸€ä¸ªèŠ‚ç‚¹çš„æ•°æ®å‘ç”Ÿç¯¡æ”¹ï¼Œæœ€ç»ˆéƒ½ä¼šå½±å“åˆ°æ ¹æ‰¿è¯ºã€‚</p>
<p><strong>å¦‚ä½•ç”Ÿæˆè¯æ˜ï¼Ÿ</strong>å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œåªéœ€è¦æä¾›ä¸‰ä¸ªå­è¯æ˜ï¼Œæ¯ä¸ªå­è¯æ˜å¯ä»¥è¯æ˜è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ˜¯å­˜åœ¨äºçˆ¶èŠ‚ç‚¹çš„æŸä¸ªä½ç½®ä¸Šã€‚å¦‚æœå®½åº¦è¶Šå¤§ï¼Œå±‚æ•°è¶Šå°‘ï¼Œéœ€è¦çš„å­è¯æ˜æ•°é‡ä¹Ÿå°±è¶Šå°‘äº†ã€‚</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/09.png" alt="image"></p>
<p>å®é™…å®ç°ä¸­ï¼Œä¼šä½¿ç”¨å¤šé¡¹å¼æ‰¿è¯ºï¼ˆå¯ä»¥ç®€å•é«˜æ•ˆåœ°å®ç°å‘é‡æ‰¿è¯ºï¼‰ï¼Œå…¶å…è®¸å¯¹ä¸€ä¸ªå¤šé¡¹å¼è¿›è¡Œæ‰¿è¯ºã€‚æœ€å®¹æ˜“ä½¿ç”¨çš„ä¸¤ç§å¤šé¡¹å¼æ‰¿è¯ºæ–¹æ¡ˆæ˜¯ â€œ<a href="https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html" target="_blank" rel="noopener">KZG æ‰¿è¯º</a>â€ å’Œ â€œ<a href="https://twitter.com/VitalikButerin/status/1371844878968176647" target="_blank" rel="noopener">bulletproof ç±»å‹çš„æ‰¿è¯º</a>â€ï¼ˆåœ¨ä¸¤ç§æ–¹æ¡ˆä¸­ï¼Œä¸€ä¸ªæ‰¿è¯ºéƒ½æ˜¯å•ä¸ª 32 ï½ 48 å­—èŠ‚çš„æ¤­åœ†æ›²çº¿ç‚¹ï¼‰ã€‚</p>
<p><strong>å¦‚æœä½ ä½¿ç”¨ KZG æ‰¿è¯ºå’Œè¯æ®ï¼Œæ¯ä¸ªä¸­é—´èŠ‚ç‚¹çš„è¯æ®åªæœ‰ 96 å­—èŠ‚ï¼Œæ¯”èµ·ç®€å•Merkleæ ‘æœ‰æ¥è¿‘ 3 å€çš„ç©ºé—´èŠ‚çº¦ï¼ˆå‡è®¾å®½åº¦ä¸º 256ï¼‰ã€‚</strong></p>
<p>Merkleæ ‘å’ŒVerkleæ ‘çš„æ“ä½œç†è®ºæ—¶é—´ä»£ä»·å¦‚ä¸‹ï¼š</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/10.png" alt="image"></p>
<p>ç›®å‰ä¸ºæ­¢ä»‹ç»çš„Verkleè¯æ˜æ–¹æ¡ˆè¿˜æ¯”è¾ƒåŸºç¡€ï¼Œå®é™…ä¸Šè¿˜æœ‰æ›´è¿›ä¸€æ­¥çš„ä¼˜åŒ–æ–¹æ¡ˆã€‚</p>
<h2 id="ä¼˜åŒ–ï¼šåˆå¹¶è¯æ˜"><a href="#ä¼˜åŒ–ï¼šåˆå¹¶è¯æ˜" class="headerlink" title="ä¼˜åŒ–ï¼šåˆå¹¶è¯æ˜"></a>ä¼˜åŒ–ï¼šåˆå¹¶è¯æ˜</h2><h3 id="æ€è·¯"><a href="#æ€è·¯" class="headerlink" title="æ€è·¯"></a>æ€è·¯</h3><p>ç›¸æ¯”äºä¸ºè·¯å¾„çš„æ¯ä¸€å±‚æ‰¿è¯ºç”Ÿæˆä¸€ä¸ªè¯æ˜ï¼Œå¯ä»¥ä½¿ç”¨å¤šé¡¹å¼æ‰¿è¯ºçš„ç‰¹å¾æ¥å®ç°â€œç”¨ä¸€ä¸ªå›ºå®šå¤§å°çš„è¯æ˜è¯æ˜è·¯å¾„ä¸Šæ‰€æœ‰æ‰¿è¯ºä¹‹é—´çš„çˆ¶å­å…³ç³»ï¼Œå¹¶ä¸”å¯ä»¥åŒ…å«æ— é™é‡çš„å…ƒç´ â€ã€‚å¦‚æœæƒ³è¦æ›´å…·ä½“åœ°äº†è§£æ˜¯åšåˆ°è¿™ä¸€ç‚¹ï¼Œå°±å¿…é¡»å¼•å…¥ä¸€äº›æ•°å­¦çŸ¥è¯†æ¥åšè¯´æ˜äº†ï¼Œæœ¬æ–‡çš„è®²è§£ä¼šæ¶‰åŠä¸€äº›æ•°å­¦å…¬å¼ï¼Œä½†ä¸ä¼šå¼•å…¥å¯†ç å­¦éƒ¨åˆ†çš„åŸç†è¯æ˜ã€‚å…·ä½“æ–¹æ³•è¯·å‚è€ƒ<a href="https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html" target="_blank" rel="noopener">scheme that implements multiproofs through random evaluation</a>ã€‚</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/11.png" alt="image"></p>
<h3 id="æ•°å­¦è¯æ˜"><a href="#æ•°å­¦è¯æ˜" class="headerlink" title="æ•°å­¦è¯æ˜"></a>æ•°å­¦è¯æ˜</h3><p>é¦–å…ˆæˆ‘ä»¬æ¥ä»‹ç»ä¸€ä¸‹æ•°å­¦ä¸­å…³äºå¤šé¡¹å¼çš„åŸºç¡€æ¦‚å¿µï¼šå¦‚ä½•å¯¹ä¸€ä¸ªå¤šé¡¹å¼è¿›è¡Œé™é˜¶ï¼Ÿ</p>
<p>å¦‚æœæˆ‘ä»¬çŸ¥é“ä¸€ä¸ªå¤šé¡¹å¼$P(x)$ å’Œå®ƒåœ¨æŸä¸€ç‚¹$x_1$çš„å€¼ä¸º$y_1$ï¼Œé‚£ä¹ˆ $P(x_1) &#x3D; y_1$ã€‚</p>
<p>ç°åœ¨ï¼Œè€ƒè™‘ä¸€ä¸ªæ–°çš„å¤šé¡¹å¼$P(x) - y_1$ï¼Œå®ƒåœ¨$( x &#x3D; x_1 )$ å¤„çš„å€¼æ˜¯é›¶ï¼Œå› ä¸º $P(x_1) - y_1 &#x3D; y_1 - y_1 &#x3D; 0$ã€‚</p>
<p>å› æ­¤ï¼Œ$P(x) - y_1$è¿™ä¸ªå¤šé¡¹å¼åœ¨ $x &#x3D; x_1$ å¤„æœ‰ä¸€ä¸ªæ ¹ï¼Œå³ $(x - x_1)$ æ˜¯$P(x) - y_1$çš„ä¸€ä¸ªå› å­ã€‚</p>
<p>æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºè¿™æ ·çš„å½¢å¼ï¼š$[ P(x) - y_1 &#x3D; (x - x_1)Q(x) ]$</p>
<p>å…¶ä¸­$Q(x)$æ˜¯å¦ä¸€ä¸ªå¤šé¡¹å¼ï¼Œå…¶æ¬¡æ•°æ¯”$P(x)$å°‘ä¸€ã€‚è¿™æ˜¯å› ä¸º $(x - x_1)$ æ˜¯ä¸€ä¸ªä¸€é˜¶å› å­ï¼Œå®ƒé™ä½äº†å¤šé¡¹å¼çš„æ€»æ¬¡æ•°ã€‚</p>
<p><strong>å¦‚ä½•ä½¿ç”¨KZGæ¥è¯æ˜å‘é‡ä¸­çš„å•ä¸ªå€¼ï¼Ÿ</strong><br>ä»¥KZG10æ‰¿è¯ºä¸ºä¾‹ï¼Œå¯¹äºå¤šé¡¹å¼$P(x)$,è®¾å…¶å¤šé¡¹å¼æ‰¿è¯ºä¸º$[P(s)]_1$ã€‚</p>
<p>å‰æ–‡å·²ç»è¯´æ˜ï¼Œå¯¹äºå¤šé¡¹å¼$P(x)$ï¼Œå¦‚æœæœ‰$P(z)&#x3D;y$,åˆ™æœ‰$Q(x)&#x3D;(P(x)-y)&#x2F;(x-z)$ã€‚</p>
<p>ç°åœ¨è¯æ˜è€…å¯ä»¥ä¸ºå¤šé¡¹å¼$P(x)$æ»¡è¶³$P(z)&#x3D;y$ç”Ÿæˆä¸€ä¸ªè¯æ˜ï¼šè®¡ç®—$[Q(s)]_1$å¹¶å‘é€ç»™éªŒè¯è€…ã€‚</p>
<p>éªŒè¯è€…éœ€è¦éªŒè¯$e([Q(s)]_1,[s-z]_2)&#x3D;e([P(s)]_1-[y]_1,[1]_2)$ã€‚</p>
<p><strong>å¦‚ä½•ä½¿ç”¨KZGæ¥è¯æ˜å‘é‡ä¸­çš„å¤šä¸ªå€¼ï¼Ÿ</strong><br>æˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªè¯æ˜æ¥è¯æ˜å‘é‡ä¸­çš„å¤šä¸ªå€¼ï¼Œå…·ä½“åšæ³•å¦‚ä¸‹ï¼š</p>
<p>è®¾éªŒè¯è€…æƒ³è¯æ˜å¤šé¡¹å¼$P(x)$ï¼Œåœ¨$(z_0, z_1,\ldots,z_{k-1})$ä¸Šçš„å€¼ä¸º$(y_0, y_1,\ldots,y_{k-1})$ã€‚<br>å®šä¹‰ä¸¤ä¸ªå¤šé¡¹å¼ï¼š</p>
<ul>
<li><p>$I(x) : I(z_i) = y_i \quad \text{å¯¹äºæ‰€æœ‰} i \in [0, k]$</p>
</li>
<li><p>$V(x) = \prod_{i=0}^{k-1}(x - x_i)$</p>
</li>
</ul>
<p>é‚£ä¹ˆåŒç†ï¼Œå­˜åœ¨å¤šé¡¹å¼$Q(x)$ï¼Œæ»¡è¶³$Q(x) *V(x) &#x3D; P(x) - I(x)$ã€‚</p>
<p>è¯æ˜è€…è®¡ç®—å¯¹å¤šé¡¹å¼$P(x)$ã€$Q(x)$çš„æ‰¿è¯º$[P(s)]_1$ã€$[Q(s)]_1$ä½œä¸ºè¯æ˜å‘é€ç»™éªŒè¯è€…ï¼ŒéªŒè¯è€…å¯ä»¥åœ¨æœ¬åœ°è®¡ç®—$[I(s)]_1$ã€$[V(s)]_2$ï¼ŒéªŒè¯è€…éªŒè¯$e([Q(s)]_1,[V(s)]_2) &#x3D; e([P(s)]_1 - [I(s)]_1, H)$ã€‚</p>
<p>é€šè¿‡è¿™ç§æ–¹å¼ï¼Œä¸ç®¡æƒ³è¦éªŒè¯åŒä¸€å‘é‡ä¸­çš„æ•°æ®æ•°é‡æœ‰å¤šå°‘ä¸ªï¼Œéƒ½åªéœ€è¦æ’å®šå¤§å°çš„è¯æ˜å³å¯ã€‚</p>
<p><strong>ç°åœ¨æˆ‘ä»¬ä»KZGæ‰¿è¯ºç®—æ³•çš„è§’åº¦æ¥çœ‹æ²¡æœ‰ä¼˜åŒ–å‰çš„Verkle Treeæ–¹æ¡ˆ</strong></p>
<p>è®¾éªŒè¯è€…æƒ³è¯æ˜å¤šé¡¹å¼é›†åˆ $f_0(x),f_1(x),\ldots,f_{m-1}(x)$ï¼Œåœ¨ $(z_0, z_1,\ldots,z_{m-1})$ ä¸Šæ»¡è¶³:<br>$f_i(z_i)=y_i,\quad i \in [0, m-1]$</p>
<p>é€šè¿‡â€œ<strong>å¦‚ä½•ä½¿ç”¨KZGæ¥è¯æ˜å‘é‡ä¸­çš„å•ä¸ªå€¼</strong>â€éƒ¨åˆ†çš„æ„é€ æ–¹å¼ï¼ŒéªŒè¯å¯ä»¥ä¸ºæ¯ä¸ªå¤šé¡¹å¼$f_i(x)$æ„é€ åŸå¤šé¡¹å¼å’Œå•†å¤šé¡¹å¼çš„æ‰¿è¯ºï¼Œæ€»è®¡ $2*m$ ä¸ªKZGæ‰¿è¯ºã€‚å°†è¿™ä¹ˆå¤šæ‰¿è¯ºä½œä¸ºè¯æ˜å‘é€ç»™éªŒè¯è€…è¿›è¡ŒéªŒè¯ã€‚</p>
<p>ä½†æ˜¯æ­£å¦‚å‰é¢è¯´åˆ°çš„ï¼Œè¿™æ ·éœ€è¦ç”Ÿæˆå¤šä¸ªè¯æ˜ï¼ŒéªŒè¯è€…ä¹Ÿéœ€è¦å¤šæ¬¡éªŒè¯è®¡ç®—ã€‚æˆ‘ä»¬éœ€è¦æƒ³åŠæ³•æŠŠå¤šä¸ªæ‰¿è¯ºè¯æ˜è¿›è¡Œå‹ç¼©ã€‚</p>
<p><strong>åˆå¹¶è¯æ˜çš„ä¼˜åŒ–æ–¹æ¡ˆ</strong></p>
<p>éªŒè¯è€…å…ˆéšæœºç”Ÿæˆä¸€ç³»åˆ—éšæœºæ•° $(r_0, r_1,\ldots,r_{m-1})$ï¼Œç„¶åæŠŠä¸Šè¿°å•†å¤šé¡¹å¼ç»„åˆåœ¨ä¸€èµ·ï¼š</p>
<p>$g(x) = r_0q_0(z) + r_1q_1(z) + \ldots + r_{m-1}q_{m-1}(z)$</p>
<p>å‡è®¾å½“ä¸”ä»…å½“æ¯ä¸ªå•†å¤šé¡¹å¼ç¡®å®ä¸ºå¤šé¡¹å¼æ—¶ï¼Œ$g(x)$ æ‰æ˜¯ä¸€ä¸ªå¤šé¡¹å¼ã€‚è¿™æ˜¯ä¸€ä¸ªåˆç†çš„å‡è®¾ï¼Œå› ä¸ºéšæœºæ•°æ°å¥½æŠŠæ‰€æœ‰å•†å¤šé¡¹å¼å„æ¬¡çš„ç³»æ•°å…¨éƒ¨æŠµæ¶ˆçš„æ¦‚ç‡å¾ˆä½ã€‚</p>
<p>è¯æ˜è€…ä¼šå¯¹ $g(x)$ æ„é€ æ‰¿è¯º $[g(s)]_1$ å¹¶å‘é€ç»™éªŒè¯è€…ã€‚ä½†æ˜¯è¿˜éœ€è¦æ„é€ ä¸€äº›æ‰¿è¯ºè®©éªŒè¯è€…ç›¸ä¿¡ $[g(s)]_1$ æ˜¯ $g(x)$ çš„æ‰¿è¯ºã€‚</p>
<p>ä»¤ $g(x)&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{f_i(x)-y_i}{x-z_i}&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{f_i(x)}{x-z_i}-\sum_{i&#x3D;0}^{m-1}r_i\frac{y_i}{x-z_i}$</p>
<p>éšæœºé€‰å–tå€¼ï¼Œä»£å…¥å¾—ï¼š</p>
<p>$g(t)=\sum_{i=0}^{m-1}r_i\frac{f_i(t)-y_i}{t-z_i}=\sum_{i=0}^{m-1}r_i\frac{f_i(t)}{t-z_i}-\sum_{i=0}^{m-1}r_i\frac{y_i}{t-z_i}$</p>
<p>æ¥ç€å®šä¹‰å¦‚ä¸‹å¤šé¡¹å¼ï¼š</p>
<p>$h(x)=\sum_{i=0}^{m-1}r_i\frac{f_i(x)}{t-z_i}$</p>
<p>$h(x)$ æ‰¿è¯ºçš„è®¡ç®—æ–¹å¼å…¶å®å¯ä»¥è¡¨ç¤ºä¸º</p>
<p>$[h(s)]_1=\sum_{i=0}^{m-1}r_i\frac{C_i}{t-z_i}$ï¼Œ$C_i$ ä¸º $[f_i(s)]1$</p>
<p>å› ä¸ºå¤šé¡¹å¼ $h(x)-g(x)$ åœ¨ $x&#x3D;t$ æ—¶æœ‰ï¼š$h(t)-g(t)&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{y_i}{t-z_i}$ï¼Œ</p>
<p>æ‰€ä»¥å¯ä»¥ä¸º $h(x)-g(x)$ æ„é€ å…¶åœ¨ $x&#x3D;t$ æ—¶ $y&#x3D;\sum_{i&#x3D;0}^{m-1}r_i\frac{y_i}{t-z_i}$çš„è¯æ˜ï¼Œå¯¹åº”çš„å•†å¤šé¡¹å¼ä¸ºï¼š</p>
$$q(x)=(h(x)-g(x)-y)/(x-t)$$

<p>å°†è¯æ˜ $[q(s)]_1$ å‘é€ç»™éªŒè¯è€…è¿›è¡ŒéªŒè¯ã€‚</p>
<p>è¯¥æ–¹æ¡ˆç”Ÿæˆçš„çš„è¯æ®ä¸ºä¸€ä¸ªæ‰¿è¯ºã€ä¸¤ä¸ªè¯æ˜å’Œä¸€ä¸ªå€¼ï¼Œæ•°æ®å¤§å°æ’å®šã€‚</p>
<p>æœ€ç»ˆï¼Œåœ¨Verkleæ ‘åˆå¹¶è¯æ˜ä¼˜åŒ–åï¼Œå‘é€ç»™éªŒè¯è€…çš„å¯éªŒè¯æ•°æ®å¯¹è±¡åŒ…å«ä»¥ä¸‹å†…å®¹ï¼š</p>
<ol>
<li><p>æ’å®šå¤§å°çš„è¯æ®</p>
</li>
<li><p>æƒ³è¯æ˜çš„å¶å­èŠ‚ç‚¹æ•°æ®ï¼ˆé”®å€¼å¯¹ï¼‰</p>
</li>
<li><p>å¶å­èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹çš„æ‰¿è¯ºå€¼ï¼ˆå‡è®¾æ ‘å®½åº¦ä¸º256ï¼Œæœ‰2^32ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¹³å‡æ·±åº¦ä¸º4ï¼Œåªéœ€æä¾›3ä¸ªæ‰¿è¯ºå€¼ï¼‰</p>
</li>
</ol>
<p>æ³¨æ„ï¼Œ$x_i$å’Œ$y_i$ä¸éœ€è¦æ˜¾å¼æä¾›ï¼Œéƒ½å¯ä»¥è¢«è®¡ç®—å‡ºæ¥ã€‚</p>
<h3 id="æ€§èƒ½"><a href="#æ€§èƒ½" class="headerlink" title="æ€§èƒ½"></a>æ€§èƒ½</h3><p>å°±Verkleæ ‘çš„åˆå¹¶è¯æ˜æ–¹æ¡ˆè€Œè¨€ï¼Œå…¶ç”Ÿæˆçš„è¯æ˜å…·ä½“å¤§å°å¦‚ä¸‹ï¼š</p>
<p><img src="/2024/01/25/Ethereum-s-Efficient-Verifiable-Query-Technique-Verkle-Trees/12.png" alt="image"></p>
<p>è¡Œä¸ºæ ‘çš„å¤§å°ï¼Œå•ä½ä¸ºbillionï¼›åˆ—ä¸ºæŸ¥è¯¢çš„é”®å€¼å¯¹æ•°é‡ã€‚</p>
<p>ä»¥ä¸Šæ•°æ®å‡è®¾ä½¿ç”¨æ ‘å®½åº¦ä¸º256ï¼Œä½¿ç”¨KZGæ‰¿è¯ºæ–¹æ¡ˆï¼ˆä¸€ä¸ªæ‰¿è¯ºå¤§å°ä¸º48å­—èŠ‚ï¼‰ï¼Œæ ‘çš„åˆ©ç”¨ç‡æœ€å¤§åŒ–ã€‚å®é™…æƒ…å†µï¼Œå¦‚æœæ˜¯å®Œå…¨éšæœºåˆ†å¸ƒçš„ä¿¡æ¯ï¼Œæ ‘æ·±åº¦å¢åŠ çº¦60%ï¼Œæ¯ä¸ªå…ƒç´ å¢åŠ 30å­—èŠ‚å¤§å°ã€‚è‹¥ä½¿ç”¨bulletproofæ–¹æ¡ˆï¼Œåˆ™æ‰¿è¯ºå¤§å°ä¸º32å­—èŠ‚ã€‚</p>
<h1 id="è¯æ˜è€…å’ŒéªŒè¯è€…çš„è®¡ç®—å¼€é”€"><a href="#è¯æ˜è€…å’ŒéªŒè¯è€…çš„è®¡ç®—å¼€é”€" class="headerlink" title="è¯æ˜è€…å’ŒéªŒè¯è€…çš„è®¡ç®—å¼€é”€"></a>è¯æ˜è€…å’ŒéªŒè¯è€…çš„è®¡ç®—å¼€é”€</h1><ol>
<li><p>ç”Ÿæˆè¯æ˜ï¼šè¯æ˜è€…ç”Ÿæˆè¯æ˜çš„å¼€é”€å’Œæ ‘çš„å®½åº¦æœ‰å…³ï¼Œä½†æ˜¯æ¯ä¸ªå•å…ƒæ“ä½œéœ€è¦çš„è®¡ç®—ä»£ä»·æ¯”è¾ƒå°ï¼Œæ‰€ä»¥Verkleæ ‘çš„å®½åº¦åœ¨256è‡³1024ä¹‹é—´çš„ç®—æ³•è¡¨ç°ä¸é”™ã€‚</p>
</li>
<li><p>éªŒè¯è¯æ˜ï¼švitalikè¡¨ç¤ºéªŒè¯ç®—æ³•å¾ˆå¿«ï¼ŒåŸºæœ¬å¯ä»¥åœ¨100mså†…å®Œæˆï¼Œå³ä½¿æƒ³è¦éªŒè¯çš„æ•°å€¼æœ‰å‡ åƒä¸ªã€‚</p>
</li>
<li><p>å½“æ›´æ–°Verkleæ ‘æ—¶ï¼šæ›´æ–°æ ‘çš„æ—¶å€™ï¼Œå› ä¸ºå€¼æˆ–è€…ç»“æ„å‘ç”Ÿäº†å˜åŒ–ï¼Œé€šå¸¸éœ€è¦é‡æ–°è®¡ç®—è·¯å¾„ä¸Šæ‰€æœ‰çš„ä¸­é—´æ‰¿è¯ºå€¼ã€‚ä½†æ˜¯vitalikè¡¨ç¤ºï¼Œæ ¹æ®å¤šé¡¹å¼æ‰¿è¯ºç®—æ³•çš„ä¸€äº›æ€§è´¨ï¼Œå¯ä»¥è®¾è®¡é¢„å…ˆè®¡ç®—å¤‡ç”¨çš„æ‰¿è¯ºå€¼å¹¶å­˜å‚¨ä¸‹æ¥ï¼Œä»è€Œå‡å°‘æ›´æ–°æ—¶çš„è®¡ç®—æ—¶é—´å¼€é”€ï¼Œå³ç”¨ç©ºé—´æ¢å–æ—¶é—´ã€‚</p>
</li>
</ol>
<h1 id="æ€»ç»“"><a href="#æ€»ç»“" class="headerlink" title="æ€»ç»“"></a>æ€»ç»“</h1><p>å¯¹æ¯”Merkleæ ‘ï¼ŒVerkleæ ‘æ˜¯éå¸¸å¼ºå¤§çš„å‡çº§ï¼Œå®ƒä½¿æˆ‘ä»¬å¯ä»¥åšå‡ºå°å¾—å¤šçš„è¯æ®ã€‚è¿ç”¨Verkleæ ‘ä¹‹åï¼Œè¯æ˜è€…ä¸å†éœ€è¦æä¾›è·¯å¾„ä¸Šæ‰€ä»¥å±‚çº§çš„æ‰€æœ‰ â€œå§å¦¹èŠ‚ç‚¹â€ï¼Œåªéœ€ä¸ºä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡å¶å­èŠ‚ç‚¹è·¯å¾„ä¸Šçš„æ‰€æœ‰æ‰¿è¯ºå€¼ä¹‹é—´çš„çˆ¶å­å…³ç³»æä¾›ä¸€ä¸ªè¯æ®ã€‚åªæ­¤ä¸€ç‚¹ï¼Œå°±å¯ä»¥è®©è¯æ®çš„å¤§å°ç¼©å°çº¦ 6 ï½ 8 å€ï¼ˆå¯¹æ¯”ç†æƒ³çš„Merkleæ ‘ï¼‰ï¼Œè‹¥æ˜¯å¯¹æ¯”ä»¥å¤ªåŠå½“å‰æ‰€ç”¨çš„MPTï¼Œå¯ç¼©å°è¶…è¿‡ 20 ï½ 30 å€ã€‚</p>
<p>Verkleæ ‘éœ€è¦æ›´å¤æ‚çš„å¯†ç å­¦æ¥å®ç°ï¼Œä½†å®ƒæœ‰æœºä¼šç»™å¯æ‰©å±•æ€§å¸¦æ¥å·¨å¤§æ”¶ç›Šã€‚ä»ä¸­æœŸæ¥çœ‹ï¼ŒSNARK å¯ä»¥æå‡æ›´å¤šï¼šæˆ‘ä»¬æ—¢å¯ä»¥ SNARK åŒ–å·²ç»å¾ˆæœ‰æ•ˆç‡çš„ Verkleè¯æ®éªŒè¯è€…ï¼ŒæŠŠè§è¯æ•°æ®çš„å¤§å°é™ä½åˆ°è¿‘äºé›¶ï¼›æˆ–è€…åˆ‡æ¢å› SNARK åŒ–çš„Merkleè¯æ®ï¼Œåªè¦ SNARK å¯ä»¥å˜å¾—æ›´å¥½ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡ GKRã€æˆ–è€… SNARK æåº¦å‹å¥½å‹çš„å“ˆå¸Œå‡½æ•°ï¼Œæˆ–è€… ASICï¼‰ã€‚æ›´è¿›ä¸€æ­¥åœ°è¯´ï¼Œé‡å­è®¡ç®—çš„å…´èµ·ä¼šè®©Verkleæ ‘æ‰€ä¾èµ–çš„çº¿æ€§åŒæ€å±æ€§å˜å¾—ä¸å®‰å…¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¿…é¡»è½¬å‘ SNARK åŒ–çš„Merkleè¯æ®ã€‚ä½†ä»ç›®å‰æ¥çœ‹ï¼ŒVerkleæ ‘ç»™äº†æˆ‘ä»¬åŒæ ·çš„å¯æ‰©å±•æ€§æ”¶ç›Šï¼ˆæ¯”èµ·å…¶ä»–æ›´é«˜çº§çš„æŠ€æœ¯ï¼‰ï¼Œè€Œæˆ‘ä»¬å·²ç»å…·å¤‡äº†é«˜æ•ˆå®ç°Verkleæ ‘æ‰€éœ€çš„æ‰€æœ‰å·¥å…·ã€‚</p>
<p>ç›®å‰è®¸å¤šä»¥å¤ªåŠå®¢æˆ·ç«¯å·²ç»æä¾›Verkleæ ‘çš„å®ç°å¹¶æœ‰ç›¸å…³æµ‹è¯•ç½‘ï¼Œå…³äºVerkleæ ‘ä¸Šçº¿ä¸»ç½‘çš„æ—¶é—´ç¤¾åŒºä»æ—§åœ¨è®¨è®ºï¼Œæœ‰è¾ƒå¤§å¯èƒ½ä¼šåœ¨2024æˆ–è€…2025çš„æŸæ¬¡ç¡¬åˆ†å‰å‡çº§ä¸­å®ç°ã€‚ä»¥å¤ªåŠä¸Šå…³äºVerkleæ ‘çš„è¯¦ç»†ä¿¡æ¯è§<a href="https://verkle.info/" target="_blank" rel="noopener">https://verkle.info/</a> ã€‚</p>
<h1 id="å‚è€ƒ"><a href="#å‚è€ƒ" class="headerlink" title="å‚è€ƒ"></a>å‚è€ƒ</h1><p>[1]. BRASSARD G, CHAUM D, CREÌPEAU C. Minimum disclosure proofs of knowledge[J].  Journal of computer and system sciences, 1988, 37(2): 156-189.  	</p>
<p>[2]. CATALANO D, FIORE D. Vector commitments and their applications[C]&#x2F;&#x2F;Public-KeyCryptographyâ€“PKC 2013: 16th International Conference on Practice and Theory in Public- Key Cryptography, Nara, Japan, February 26â€“March 1, 2013. Proceedings 16. Springer, 2013: 55-72.  	</p>
<h1 id="å…³äºæˆ‘ä»¬-About-Us"><a href="#å…³äºæˆ‘ä»¬-About-Us" class="headerlink" title="å…³äºæˆ‘ä»¬ About Us"></a>å…³äºæˆ‘ä»¬ About Us</h1><h2 id="AntChain-Open-Labs-1"><a href="#AntChain-Open-Labs-1" class="headerlink" title="AntChain Open Labs"></a><strong>AntChain Open Labs</strong></h2><p>AntChain Open Labs is a research center initiated by AntChain and world leading computer scientists in the area of foundational trust technologies. It is dedicated to building a secure, transparent and reliable Web3 infrastructure driven by innovative research and aiming to advance transformative services.<br>Websiteï¼š<a href="https://openlabs-intl.antdigital.com/home" target="_blank" rel="noopener">https://openlabs-intl.antdigital.com/home</a>  </p>
<h2 id="ZAN-1"><a href="#ZAN-1" class="headerlink" title="ZAN"></a><strong>ZAN</strong></h2><p>ZANæ˜¯èš‚èšæ•°ç§‘æ——ä¸‹æ–°ç§‘æŠ€å“ç‰Œã€‚ä¾æ‰˜AntChain Open Labsçš„TrustBaseå¼€æºå¼€æ”¾æŠ€æœ¯ä½“ç³»ï¼Œæ‹¥æœ‰Web3é¢†åŸŸç‹¬ç‰¹çš„ä¼˜åŠ¿å’Œåˆ›æ–°èƒ½åŠ›ï¼Œä¸ºWeb3ç¤¾åŒºæä¾›å¯é ã€é«˜æ€§ä»·æ¯”çš„åŒºå—é“¾åº”ç”¨å¼€å‘æŠ€æœ¯äº§å“å’ŒæœåŠ¡ã€‚</p>
<p>å‡­å€ŸAntChain Open Labsçš„æŠ€æœ¯æ”¯æŒï¼ŒZANä¸ºä¼ä¸šå’Œå¼€å‘è€…æä¾›äº†å…¨é¢çš„æŠ€æœ¯äº§å“å’ŒæœåŠ¡ï¼Œå…¶ä¸­åŒ…æ‹¬æ™ºèƒ½åˆçº¦å®¡è®¡ï¼ˆZAN Smart Contract Reviewï¼‰ã€èº«ä»½éªŒè¯eKYCï¼ˆZAN Identityï¼‰ã€äº¤æ˜“é£æ§æŠ€æœ¯ï¼ˆZAN Know Your Transactionï¼‰ä»¥åŠèŠ‚ç‚¹æœåŠ¡ï¼ˆZAN Node Serviceï¼‰ç­‰ã€‚   </p>
<p>é€šè¿‡ZANçš„ä¸€ç«™å¼è§£å†³æ–¹æ¡ˆï¼Œç”¨æˆ·å¯ä»¥äº«å—åˆ°å…¨æ–¹ä½çš„Web3æŠ€æœ¯æ”¯æŒã€‚   </p>
<p>ZAN Websiteï¼š<a href="https://zan.top/home" target="_blank" rel="noopener">https://zan.top/home</a>   </p>
<p><a href="https://zan.top/home" target="_blank" rel="noopener">Website</a> | <a href="https://t.me/ZANTeam" target="_blank" rel="noopener">Telegram</a> | <a href="http://discord.gg/KucRCH9Mcb" target="_blank" rel="noopener">Discocd</a> |  <a href="https://x.com/zan_team" target="_blank" rel="noopener">Twitter</a> | <a href="https://linktr.ee/zan_team" target="_blank" rel="noopener">More</a></p>


                <hr>

                

                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/2024/01/24/Principle-and-Architecture-of-zkRollup/" data-toggle="tooltip" data-placement="top" title="Principle and Architecture of zkRollup">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/AntChainOpenLabs">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; AntChain Open Labs 2024 
                    <br>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX"],
      tex2jax: {
        inlineMath: [ ['$','$'], ['\\(','\\)'] ],
        displayMath: [ ['$$','$$']],
        processEscapes: true
      }
    });
</script>
<script>
    window.MathJax = {
      tex: {
        inlineMath: [ ['$','$'], ['\\(','\\)'] ],
        displayMath: [ ['$$','$$']],
        processEscapes: true,
      },
      options: {
      renderActions: {
        findScript: [10, function (doc) {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/);
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
            const text = document.createTextNode('');
            node.parentNode.replaceChild(text, node);
            math.start = {node: text, delim: '', n: 0};
            math.end = {node: text, delim: '', n: 0};
            doc.math.push(math);
          }
        }, '']
      }
    }
    };
</script>
<script type="text/javascript" id="MathJax-script" src="/js/mathjax/tex-chtml.js">
</script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://antchainopenlabs.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7F0NSTH00H"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-7F0NSTH00H');
    </script>

<!-- 

<script>
    // dynamic User by Hux
    var _gaId = 'G-7F0NSTH00H';
    var _gaDomain = 'https://antchainopenlabs.github.io';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script> -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="https://antchainopenlabs.github.io/img/logo.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
